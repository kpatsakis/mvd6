int av_read_packet(AVFormatContext *s,AVPacket *pkt) return ff_read_packet ( s , pkt ) ; int ff_read_packet(AVFormatContext *s,AVPacket *pkt) int ret ; AVStream * st ; AVPacketList * pktl = s -> raw_packet_buffer ; if ( pktl )  * pkt = pktl -> pkt; st = s -> streams [ pkt -> stream_index ]; if ( st -> request_probe <= 0 )  pkt -> data = ( ( void * ) 0 ); pkt -> size = 0; ret = ( ( s -> iformat -> read_packet ) ( s , pkt ) ); if ( ret < 0 )  if ( ! pktl || ret == - '\v' )  if ( s -> flags & 0x0100 && pkt -> flags & 0x0002 )  if ( ( pkt -> stream_index ) >= ( ( unsigned int ) ( s -> nb_streams ) ) )  st = s -> streams [ pkt -> stream_index ]; pkt -> dts = wrap_timestamp ( st , pkt -> dts ); static int64_t wrap_timestamp(AVStream *st,int64_t timestamp) return timestamp ; pkt -> pts = wrap_timestamp ( st , pkt -> pts ); static int64_t wrap_timestamp(AVStream *st,int64_t timestamp) return timestamp ; if ( s -> use_wallclock_as_timestamps )  pkt -> dts = pkt -> pts = av_rescale_q ( av_gettime ( ) , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) , st -> time_base ) if ( ! pktl && st -> request_probe <= 0 )  s -> raw_packet_buffer_remaining_size -= pkt -> size; probe_codec ( s , st , pkt ); static void probe_codec(AVFormatContext *s,AVStream *st,const AVPacket *pkt) if ( st -> request_probe > 0 )  AVProbeData * pd = & st -> probe_data ; if ( pkt )  uint8_t * new_buf = ( av_realloc ( ( pd -> buf ) , ( pd -> buf_size + pkt -> size + 32 ) ) ) ; if ( ! new_buf )  pd -> buf = new_buf; memcpy ( ( pd -> buf + pd -> buf_size ) , ( pkt -> data ) , ( pkt -> size ) ); pd -> buf_size += pkt -> size; memset ( ( pd -> buf + pd -> buf_size ) , 0 , 32 ); if ( end || ff_log2_c ( ( pd -> buf_size ) ) != ff_log2_c ( ( pd -> buf_size - pkt -> size ) ) )  int score = set_codec_from_probe_data ( s , st , pd ) ; static int set_codec_from_probe_data(AVFormatContext *s,AVStream *st,AVProbeData *pd) AVInputFormat * fmt = av_probe_input_format3 ( pd , 1 , & score ) ; AVInputFormat *av_probe_input_format3(AVProbeData *pd,int is_opened,int *score_ret) AVProbeData lpd = * pd ; if ( ! lpd . buf )  lpd . buf = zerobuffer; if ( lpd . buf_size > '\n' && ff_id3v2_match ( lpd . buf , "ID3" ) )  int id3len = ff_id3v2_tag_len ( lpd . buf ) ; if ( lpd . buf_size > id3len + 16 )  lpd . buf += id3len; lpd . buf_size -= id3len; if ( ! is_opened == ! ( fmt1 -> flags & 0x1 ) )  score = ( ( fmt1 -> read_probe ) ( & lpd ) ); if ( fmt1 -> extensions && av_match_ext ( lpd . filename , fmt1 -> extensions ) )  int av_match_ext(const char *filename,const char *extensions) if ( ! filename )  ext = ( strrchr ( filename , '.' ) ); if ( ext )  ext ++; p = extensions; while ( ( * p ) != '\0' && ( * p ) != ',' && ( q - ext1 ) < sizeof ( ext1 ) - 1 )  * ( q ++ ) = * ( p ++ ); * q = '\0'; if ( ! av_strcasecmp ( ext1 , ext ) )  if ( ( * p ) == '\0' )  p ++; score = ( score > ( ( nodat ? 100 / 4 - 1 : 1 ) ) ? score : ( ( nodat ? 100 / 4 - 1 : 1 ) ) ); if ( av_match_ext ( lpd . filename , fmt1 -> extensions ) )  int av_match_ext(const char *filename,const char *extensions) if ( ! filename )  ext = ( strrchr ( filename , '.' ) ); if ( ext )  ext ++; p = extensions; while ( ( * p ) != '\0' && ( * p ) != ',' && ( q - ext1 ) < sizeof ( ext1 ) - 1 )  * ( q ++ ) = * ( p ++ ); * q = '\0'; if ( ! av_strcasecmp ( ext1 , ext ) )  if ( ( * p ) == '\0' )  p ++; if ( score > score_max )  score_max = score; if ( score == score_max )  * score_ret = score_max; if ( fmt && st -> request_probe <= score )  av_log ( s , 48 , "Probe with size=%d, packets=%d detected %s with score=%d\n" , pd -> buf_size , 2500 - st -> probe_packets , fmt -> name , score ); if ( ! strcmp ( fmt -> name , fmt_id_type [ i ] . name ) )  st -> codec -> codec_id = fmt_id_type [ i ] . id; st -> codec -> codec_type = fmt_id_type [ i ] . type; if ( ( st -> codec -> codec_id ) != AV_CODEC_ID_NONE && score > 100 / 4 || end )  pd -> buf_size = 0; av_freep ( ( & pd -> buf ) ); 