int avformat_open_input(AVFormatContext **ps,const char *filename,AVInputFormat *fmt,AVDictionary **options) AVFormatContext * s = * ps ; ID3v2ExtraMeta * id3v2_extra_meta = ( ( void * ) 0 ) ; if ( ! s && ! ( s = avformat_alloc_context ( ) ) )  if ( ! s -> av_class )  if ( fmt )  s -> iformat = fmt; if ( ( ret = av_opt_set_dict ( s , & tmp ) ) < 0 )  if ( ( ret = init_input ( s , filename , & tmp ) ) < 0 )  static int init_input(AVFormatContext *s,const char *filename,AVDictionary **options) int ret ; if ( s -> pb )  s -> flags |= 0x80; if ( ! s -> iformat )  return av_probe_input_buffer ( s -> pb , & s -> iformat , filename , s , 0 , s -> probesize ) ; int av_probe_input_buffer(AVIOContext *pb,AVInputFormat **fmt,const char *filename,void *logctx,unsigned int offset,unsigned int max_probe_size) AVProbeData pd = { ( filename ? filename : "" ) , ( ( ( void * ) 0 ) ) , ( - offset ) } ; unsigned char * buf = ( ( void * ) 0 ) ; uint8_t * mime_type ; int probe_size ; int buf_offset = 0 ; if ( ! max_probe_size )  max_probe_size = ( 1 << 20 ); if ( max_probe_size > ( 1 << 20 ) )  max_probe_size = ( 1 << 20 ); if ( max_probe_size < 2048 )  return - 22 ; if ( offset >= max_probe_size )  return - 22 ; if ( ! ( * fmt ) && pb -> av_class && av_opt_get ( pb , "mime_type" , 0x1 , & mime_type ) >= 0 && mime_type )  if ( ! av_strcasecmp ( mime_type , "audio/aacp" ) )  * fmt = av_find_input_format ( "aac" ); AVInputFormat *av_find_input_format(const char *short_name) AVInputFormat * fmt = ( ( void * ) 0 ) ; while ( fmt = av_iformat_next ( fmt ) )  AVInputFormat *av_iformat_next(AVInputFormat *f) if ( f )  return f -> next ; return first_iformat ; if ( match_format ( short_name , fmt -> name ) )  static int match_format(const char *name,const char *names) const char * p ; int len ; int namelen ; if ( ! name || ! names )  return 0 ; namelen = ( strlen ( name ) ); while ( p = ( strchr ( names , ',' ) ) )  len = ( ( p - names > namelen ? p - names : namelen ) ); if ( ! av_strncasecmp ( name , names , len ) )  return 1 ; names = p + 1; return ! av_strcasecmp ( name , names ) ; return fmt ; return ( ( void * ) 0 ) ; for (probe_size = 2048; probe_size <= max_probe_size && !( *fmt); probe_size = (((probe_size << 1) > ((max_probe_size > (probe_size + 1)?max_probe_size : (probe_size + 1)))?((max_probe_size > (probe_size + 1)?max_probe_size : (probe_size + 1))) : (probe_size << 1)))) void * buftmp ; if ( probe_size < offset )  buftmp = av_realloc ( buf , ( probe_size + 32 ) ); if ( ! buftmp )  return - 12 ; buf = buftmp; if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  if ( ret != - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) )  return ret ; score = 0; ret = 0; pd . buf_size = buf_offset += ret; pd . buf = & buf [ offset ]; memset ( ( pd . buf + pd . buf_size ) , 0 , 32 ); * fmt = av_probe_input_format2 ( & pd , 1 , & score ); AVInputFormat *av_probe_input_format2(AVProbeData *pd,int is_opened,int *score_max) int score_ret ; AVInputFormat * fmt = av_probe_input_format3 ( pd , is_opened , & score_ret ) ; AVInputFormat *av_probe_input_format3(AVProbeData *pd,int is_opened,int *score_ret) AVProbeData lpd = * pd ; AVInputFormat * fmt1 = ( ( void * ) 0 ) ; AVInputFormat * fmt ; int score ; int nodat = 0 ; int score_max = 0 ; static const uint8_t zerobuffer [ 32 ] ; if ( ! lpd . buf )  lpd . buf = zerobuffer; if ( lpd . buf_size > '\n' && ff_id3v2_match ( lpd . buf , "ID3" ) )  int id3len = ff_id3v2_tag_len ( lpd . buf ) ; if ( lpd . buf_size > id3len + 16 )  lpd . buf += id3len; lpd . buf_size -= id3len; nodat = 1; fmt = ( ( void * ) 0 ); while ( fmt1 = av_iformat_next ( fmt1 ) )  AVInputFormat *av_iformat_next(AVInputFormat *f) if ( f )  return f -> next ; return first_iformat ; if ( ! is_opened == ! ( fmt1 -> flags & 0x1 ) )  score = 0; if ( fmt1 -> read_probe )  score = ( ( fmt1 -> read_probe ) ( & lpd ) ); if ( fmt1 -> extensions && av_match_ext ( lpd . filename , fmt1 -> extensions ) )  int av_match_ext(const char *filename,const char *extensions) const char * ext ; const char * p ; char ext1 [ 32 ] ; char * q ; if ( ! filename )  return 0 ; ext = ( strrchr ( filename , '.' ) ); if ( ext )  ext ++; p = extensions; q = ext1; while ( ( * p ) != '\0' && ( * p ) != ',' && ( q - ext1 ) < sizeof ( ext1 ) - 1 )  * ( q ++ ) = * ( p ++ ); if ( ! av_strcasecmp ( ext1 , ext ) )  return 1 ; if ( ( * p ) == '\0' )  p ++; return 0 ; score = ( score > ( ( nodat ? 100 / 4 - 1 : 1 ) ) ? score : ( ( nodat ? 100 / 4 - 1 : 1 ) ) ); if ( fmt1 -> extensions )  if ( av_match_ext ( lpd . filename , fmt1 -> extensions ) )  int av_match_ext(const char *filename,const char *extensions) const char * ext ; const char * p ; char ext1 [ 32 ] ; char * q ; if ( ! filename )  return 0 ; ext = ( strrchr ( filename , '.' ) ); if ( ext )  ext ++; p = extensions; q = ext1; while ( ( * p ) != '\0' && ( * p ) != ',' && ( q - ext1 ) < sizeof ( ext1 ) - 1 )  * ( q ++ ) = * ( p ++ ); if ( ! av_strcasecmp ( ext1 , ext ) )  return 1 ; if ( ( * p ) == '\0' )  p ++; return 0 ; score = '2'; if ( score > score_max )  score_max = score; fmt = fmt1; if ( score == score_max )  fmt = ( ( void * ) 0 ); return fmt ; if ( score_ret > * score_max )  return fmt ; return ( ( void * ) 0 ) ; if ( ! ( * fmt ) )  return - ( ( int ) ( ( 'I' | 'N' << 8 | 'D' << 16 ) | ( ( unsigned int ) 'A' ) << 24 ) ) ; ret = ffio_rewind_with_probe_data ( pb , & buf , pd . buf_size ); return ret ; return 0 ; if ( s -> iformat && s -> iformat -> flags & 0x1 || ! s -> iformat && ( s -> iformat = av_probe_input_format2 ( & pd , 0 , & score ) ) )  AVInputFormat *av_probe_input_format2(AVProbeData *pd,int is_opened,int *score_max) int score_ret ; AVInputFormat * fmt = av_probe_input_format3 ( pd , is_opened , & score_ret ) ; if ( score_ret > * score_max )  return fmt ; return ( ( void * ) 0 ) ; return 0 ; if ( ( ret = avio_open2 ( & s -> pb , filename , 1 | s -> avio_flags , ( & s -> interrupt_callback ) , options ) ) < 0 )  return ret ; if ( s -> iformat )  return 0 ; return av_probe_input_buffer ( s -> pb , & s -> iformat , filename , s , 0 , s -> probesize ) ; int av_probe_input_buffer(AVIOContext *pb,AVInputFormat **fmt,const char *filename,void *logctx,unsigned int offset,unsigned int max_probe_size) AVProbeData pd = { ( filename ? filename : "" ) , ( ( ( void * ) 0 ) ) , ( - offset ) } ; unsigned char * buf = ( ( void * ) 0 ) ; uint8_t * mime_type ; int probe_size ; int buf_offset = 0 ; if ( ! max_probe_size )  max_probe_size = ( 1 << 20 ); if ( max_probe_size > ( 1 << 20 ) )  max_probe_size = ( 1 << 20 ); if ( max_probe_size < 2048 )  return - 22 ; if ( offset >= max_probe_size )  return - 22 ; if ( ! ( * fmt ) && pb -> av_class && av_opt_get ( pb , "mime_type" , 0x1 , & mime_type ) >= 0 && mime_type )  if ( ! av_strcasecmp ( mime_type , "audio/aacp" ) )  * fmt = av_find_input_format ( "aac" ); void * buftmp ; if ( probe_size < offset )  buftmp = av_realloc ( buf , ( probe_size + 32 ) ); if ( ! buftmp )  return - 12 ; buf = buftmp; if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )  if ( ret != - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) )  return ret ; score = 0; ret = 0; pd . buf_size = buf_offset += ret; pd . buf = & buf [ offset ]; memset ( ( pd . buf + pd . buf_size ) , 0 , 32 ); * fmt = av_probe_input_format2 ( & pd , 1 , & score ); if ( ! ( * fmt ) )  return - ( ( int ) ( ( 'I' | 'N' << 8 | 'D' << 16 ) | ( ( unsigned int ) 'A' ) << 24 ) ) ; ret = ffio_rewind_with_probe_data ( pb , & buf , pd . buf_size ); return ret ; if ( s -> iformat -> flags & 0x0002 )  if ( ! av_filename_number_test ( filename ) )  int av_filename_number_test(const char *filename) char buf [ 1024 ] ; return filename && av_get_frame_filename ( buf , ( sizeof ( buf ) ) , filename , 1 ) >= 0 ; int av_get_frame_filename(char *buf,int buf_size,const char *path,int number) const char * p ; char * q ; char buf1 [ 20 ] ; char c ; int nd ; int len ; int percentd_found ; q = buf; p = path; percentd_found = 0; c = * ( p ++ ); if ( c == '\0' )  if ( c == '%' )  nd = 0; while ( av_isdigit ( ( * p ) ) )  nd = nd * '\n' + ( * ( p ++ ) ) - 48; c = * ( p ++ ); while ( av_isdigit ( c ) )  switch ( c )  if ( percentd_found )  percentd_found = 1; snprintf ( buf1 , sizeof ( buf1 ) , "%0*d" , nd , number ); len = ( strlen ( buf1 ) ); if ( q - buf + len > ( buf_size - 1 ) )  memcpy ( q , buf1 , len ); q += len; if ( q - buf < ( buf_size - 1 ) )  * ( q ++ ) = c; if ( ! percentd_found )  return 0 ; return - 1 ; s -> duration = s -> start_time = ( ( int64_t ) 0x8000000000000000UL ); if ( s -> iformat -> priv_data_size > 0 )  if ( ! ( s -> priv_data = av_mallocz ( ( s -> iformat -> priv_data_size ) ) ) )  if ( s -> iformat -> priv_class )  * ( ( const AVClass * * ) ( s -> priv_data ) ) = s -> iformat -> priv_class; if ( ( ret = av_opt_set_dict ( s -> priv_data , & tmp ) ) < 0 )  if ( ! ( s -> flags & 0x20000 ) && s -> iformat -> read_header )  if ( ( ret = ( ( s -> iformat -> read_header ) ( s ) ) ) < 0 )  if ( id3v2_extra_meta )  if ( ! strcmp ( s -> iformat -> name , "mp3" ) || ! strcmp ( s -> iformat -> name , "aac" ) )  