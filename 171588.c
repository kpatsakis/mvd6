void heap_multi_insert(Relation relation,HeapTuple *tuples,int ntuples,CommandId cid,int options,BulkInsertState bistate) TransactionId xid = GetCurrentTransactionId ( ) ; HeapTuple * heaptuples ; int i ; int ndone ; char * scratch = ( ( void * ) 0 ) ; Page page ; bool needwal ; Size saveFreeSpace ; needwal = ( ! ( options & 0x0001 ) && ( relation -> rd_rel -> relpersistence ) == 'p' ); saveFreeSpace = ( 8192 * ( 100 - ( ( relation -> rd_options ? ( ( StdRdOptions * ) ( relation -> rd_options ) ) -> fillfactor : 100 ) ) ) / 100 ); heaptuples = ( MemoryContextAlloc ( CurrentMemoryContext , ntuples * sizeof ( HeapTuple ) ) ); for (i = 0; i < ntuples; i++) heaptuples [ i ] = heap_prepare_insert ( relation , tuples [ i ] , xid , cid , options ); static HeapTuple heap_prepare_insert(Relation relation,HeapTuple tup,TransactionId xid,CommandId cid,int options) if ( relation -> rd_rel -> relhasoids )  if ( ! ( ( bool ) ( ( ( ( tup -> t_data -> t_infomask ) & 0x0008 ? * ( ( Oid * ) ( ( ( char * ) ( tup -> t_data ) ) + tup -> t_data -> t_hoff - sizeof ( Oid ) ) ) : ( ( Oid ) 0 ) ) ) != ( ( Oid ) 0 ) ) ) )  * ( ( Oid * ) ( ( ( char * ) ( tup -> t_data ) ) + tup -> t_data -> t_hoff - sizeof ( Oid ) ) ) = GetNewOid ( relation ); while ( 0 )  tup -> t_data -> t_infomask &= ~0xFFE0; tup -> t_data -> t_infomask2 &= ~0xC000; tup -> t_data -> t_infomask |= 0x0800; tup -> t_data -> t_choice . t_heap . t_xmin = xid; tup -> t_data -> t_choice . t_heap . t_field3 . t_cid = cid; tup -> t_data -> t_infomask &= ~0x0020; while ( 0 )  tup -> t_data -> t_choice . t_heap . t_xmax = 0; tup -> t_tableOid = relation -> rd_id; if ( ( relation -> rd_rel -> relkind ) != 'r' )  return tup ; if ( ( ( tup -> t_data -> t_infomask ) & 0x0004 ) != 0 || ( tup -> t_len ) > ( ( ( intptr_t ) ( ( 8192 - ( ( ( intptr_t ) ( ( ( size_t ) ( & ( ( PageHeaderData * ) 0 ) -> pd_linp ) ) + 4 * sizeof ( ItemIdData ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ) / 4 ) ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) )  return toast_insert_or_update ( relation , tup , ( ( void * ) 0 ) , options ) ; return tup ; if ( needwal )  scratch = ( MemoryContextAlloc ( CurrentMemoryContext , 8192 ) ); ndone = 0; while ( ndone < ntuples )  Buffer buffer ; bool all_visible_cleared = ( bool ) 0 ; int nthispage ; buffer = RelationGetBufferForTuple ( relation , ( heaptuples [ ndone ] -> t_len ) , 0 , options , bistate , & vmbuffer , ( ( void * ) 0 ) ); page = ( ( Page ) ( ( ( ( void ) ( ( bool ) 1 ) ) , ( buffer < 0 ? LocalBufferBlockPointers [ - buffer - 1 ] : ( ( Block ) ( BufferBlocks + ( ( Size ) ( buffer - 1 ) ) * 8192 ) ) ) ) ) ); for (nthispage = 1; ndone + nthispage < ntuples; nthispage++) HeapTuple heaptup = heaptuples [ ndone + nthispage ] ; if ( PageGetHeapFreeSpace ( page ) < ( ( ( intptr_t ) ( heaptup -> t_len ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) + saveFreeSpace )  if ( ( ( ( PageHeader ) page ) -> pd_flags ) & 0x0004 )  all_visible_cleared = ( ( bool ) 1 ); ( ( PageHeader ) page ) -> pd_flags &= ~0x0004; if ( needwal )  XLogRecPtr recptr ; xl_heap_multi_insert * xlrec ; XLogRecData rdata [ 2 ] ; uint8 info = 0x50 ; char * tupledata ; int totaldatalen ; char * scratchptr = scratch ; bool init ; init = ( ( ( ( ( void ) ( ( bool ) 1 ) ) , ( & heaptuples [ ndone ] -> t_self ) -> ip_posid ) ) == ( ( OffsetNumber ) 1 ) && ( ( ( ( ( PageHeader ) page ) -> pd_lower ) <= ( ( size_t ) ( & ( ( PageHeaderData * ) 0 ) -> pd_linp ) ) ? 0 : ( ( ( ( PageHeader ) page ) -> pd_lower ) - ( ( size_t ) ( & ( ( PageHeaderData * ) 0 ) -> pd_linp ) ) ) / sizeof ( ItemIdData ) ) ) == ( ( ( OffsetNumber ) 1 ) + nthispage - 1 ) ); xlrec = ( ( xl_heap_multi_insert * ) scratchptr ); scratchptr += ( ( size_t ) ( & ( ( xl_heap_multi_insert * ) 0 ) -> offsets ) ); if ( ! init )  scratchptr += nthispage * sizeof ( OffsetNumber ); tupledata = scratchptr; xlrec -> all_visible_cleared = all_visible_cleared; xlrec -> node = relation -> rd_node; xlrec -> blkno = BufferGetBlockNumber ( buffer ); xlrec -> ntuples = nthispage; for (i = 0; i < nthispage; i++) HeapTuple heaptup = heaptuples [ ndone + i ] ; xl_multi_insert_tuple * tuphdr ; int datalen ; if ( ! init )  xlrec -> offsets [ i ] = ( ( ( ( void ) ( ( bool ) 1 ) ) , ( & heaptup -> t_self ) -> ip_posid ) ); tuphdr = ( ( xl_multi_insert_tuple * ) ( ( ( intptr_t ) scratchptr ) + ( 2 - 1 ) & ~ ( ( intptr_t ) ( 2 - 1 ) ) ) ); scratchptr = ( ( char * ) tuphdr ) + ( ( ( size_t ) ( & ( ( xl_multi_insert_tuple * ) 0 ) -> t_hoff ) ) + sizeof ( uint8 ) ); tuphdr -> t_infomask2 = heaptup -> t_data -> t_infomask2; tuphdr -> t_infomask = heaptup -> t_data -> t_infomask; tuphdr -> t_hoff = heaptup -> t_data -> t_hoff; datalen = ( ( heaptup -> t_len ) - ( ( size_t ) ( & ( ( HeapTupleHeaderData * ) 0 ) -> t_bits ) ) ); memcpy ( scratchptr , ( ( ( char * ) ( heaptup -> t_data ) ) + ( ( size_t ) ( & ( ( HeapTupleHeaderData * ) 0 ) -> t_bits ) ) ) , datalen ); tuphdr -> datalen = datalen; scratchptr += datalen; totaldatalen = ( scratchptr - tupledata ); rdata [ 0 ] . data = ( ( char * ) xlrec ); rdata [ 0 ] . len = ( tupledata - scratch ); rdata [ 0 ] . buffer = 0; rdata [ 0 ] . next = & rdata [ 1 ]; rdata [ 1 ] . data = tupledata; rdata [ 1 ] . len = totaldatalen; rdata [ 1 ] . buffer = buffer; rdata [ 1 ] . buffer_std = ( ( bool ) 1 ); rdata [ 1 ] . next = ( ( void * ) 0 ); if ( init )  rdata [ 1 ] . buffer = 0; info |= 0x0080; recptr = XLogInsert ( 9 , info , rdata ); ( ( PageHeader ) page ) -> pd_lsn = recptr; ( ( PageHeader ) page ) -> pd_tli = ( ( uint16 ) ThisTimeLineID ); ndone += nthispage; 