void *hash_search(HTAB *hashp,const void *keyPtr,HASHACTION action,bool *foundPtr) return hash_search_with_hash_value ( hashp , keyPtr , ( ( hashp -> hash ) ( keyPtr , hashp -> keysize ) ) , action , foundPtr ) ; void *hash_search_with_hash_value(HTAB *hashp,const void *keyPtr,uint32 hashvalue,HASHACTION action,bool *foundPtr) HASHHDR * hctl = hashp -> hctl ; if ( action == HASH_ENTER || action == HASH_ENTER_NULL )  if ( ! ( hctl -> num_partitions != 0 ) && ! hashp -> frozen && hctl -> nentries / ( ( long ) ( hctl -> max_bucket + 1 ) ) >= hctl -> ffactor && ! has_seq_scans ( hashp ) )  static bool has_seq_scans(HTAB *hashp) int i ; for (i = 0; i < num_seq_scans; i++) if ( seq_scan_tables [ i ] == hashp )  return ( bool ) 1 ; return ( bool ) 0 ; ( void ) ( expand_table ( hashp ) ); static bool expand_table(HTAB *hashp) HASHHDR * hctl = hashp -> hctl ; long new_bucket ; long new_segnum ; new_bucket = ( hctl -> max_bucket + 1 ); new_segnum = new_bucket >> hashp -> sshift; if ( new_segnum >= hctl -> nsegs )  if ( new_segnum >= hctl -> dsize )  if ( ! dir_realloc ( hashp ) )  static bool dir_realloc(HTAB *hashp) HASHSEGMENT * p ; HASHSEGMENT * old_p ; long new_dsize ; long old_dirsize ; long new_dirsize ; if ( hashp -> hctl -> max_dsize != ( - 1 ) )  new_dsize = hashp -> hctl -> dsize << 1; old_dirsize = ( ( hashp -> hctl -> dsize ) * sizeof ( HASHSEGMENT ) ); new_dirsize = ( new_dsize * sizeof ( HASHSEGMENT ) ); old_p = hashp -> dir; p = ( ( HASHSEGMENT * ) ( ( hashp -> alloc ) ( ( ( Size ) new_dirsize ) ) ) ); if ( p != ( ( void * ) 0 ) )  memcpy ( p , old_p , old_dirsize ); void * _vstart = ( void * ) ( ( ( char * ) p ) + old_dirsize ) ; int _val = 0 ; Size _len = ( new_dirsize - old_dirsize ) ; if ( ( ( ( intptr_t ) _vstart ) & sizeof ( long ) - 1 ) == 0 && ( _len & sizeof ( long ) - 1 ) == 0 && _val == 0 && _len <= 1024 && 1024 != 0 )  memset ( _vstart , _val , _len ); while ( 0 )  