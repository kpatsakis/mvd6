svn_error_t *svn_utf_cstring_from_utf8(const char **dest,const char *src,apr_pool_t *pool) xlate_handle_node_t * node ; svn_error_t * err ; svn_error_t * svn_err__temp = check_cstring_utf8 ( src , pool ) ; static svn_error_t *check_cstring_utf8(const char *data,apr_pool_t *pool) if ( ! svn_utf__cstring_is_valid ( data ) )  return invalid_utf8 ( data , strlen ( data ) , pool ) ; static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool) const char * last = svn_utf__last_valid ( data , len ) ; const char * valid_txt = "" ; const char * invalid_txt = "" ; apr_size_t i ; size_t valid ; size_t invalid ; valid = ( last - data ); if ( valid > 24 )  valid = 24; for (i = 0; i < valid; ++i) valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) ); invalid = ( data + len - last ); if ( invalid > 4 )  invalid = 4; for (i = 0; i < invalid; ++i) invalid_txt = ( apr_pstrcat ( pool , invalid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) ); return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ; return 0 ; if ( svn_err__temp )  while ( 0 )  svn_error_t * svn_err__temp = get_uton_xlate_handle_node ( & node , pool ) ; static svn_error_t *get_uton_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool) return get_xlate_handle_node ( ret , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_APR_UTF8_CHARSET , SVN_UTF_UTON_XLATE_HANDLE , pool ) ; static svn_error_t *get_xlate_handle_node(xlate_handle_node_t **ret,const char *topage,const char *frompage,const char *userdata_key,apr_pool_t *pool) xlate_handle_node_t * old_node = ( ( void * ) 0 ) ; if ( userdata_key )  if ( xlate_handle_hash )  if ( userdata_key == SVN_UTF_NTOU_XLATE_HANDLE )  old_node = ( atomic_swap ( & xlat_ntou_static_handle , ( ( void * ) 0 ) ) ); if ( userdata_key == SVN_UTF_UTON_XLATE_HANDLE )  old_node = ( atomic_swap ( & xlat_uton_static_handle , ( ( void * ) 0 ) ) ); if ( old_node && old_node -> valid )  return 0 ; void * p ; old_node = p; if ( old_node && old_node -> valid )  return 0 ; return xlate_alloc_handle ( ret , topage , frompage , pool ) ; svn_mutex__t * svn_mutex__m = xlate_handle_mutex ; svn_error_t * svn_err__temp = svn_mutex__lock ( svn_mutex__m ) ; if ( svn_err__temp )  return svn_err__temp ; while ( 0 )  svn_error_t * svn_err__temp = svn_mutex__unlock ( svn_mutex__m , get_xlate_handle_node_internal ( ret , topage , frompage , userdata_key , pool ) ) ; if ( svn_err__temp )  return svn_err__temp ; while ( 0 )  while ( 0 )  return 0 ; if ( svn_err__temp )  while ( 0 )  err = convert_cstring ( dest , src , node , pool ); static svn_error_t *convert_cstring(const char **dest,const char *src,xlate_handle_node_t *node,apr_pool_t *pool) if ( node -> handle )  svn_error_t * svn_err__temp = convert_to_stringbuf ( node , src , strlen ( src ) , & destbuf , pool ) ; if ( svn_err__temp )  return svn_err__temp ; while ( 0 )  