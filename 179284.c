static brcmf_cfg80211_dump_station(struct wiphy *wiphy, struct net_device int idx, u8 *mac, struct station_info *sinfo) struct brcmf_cfg80211_info * cfg = wiphy_to_cfg ( wiphy ) ; struct brcmf_if * ifp = netdev_priv ( ndev ) ; s32 err ; if ( idx == 0 )  cfg -> assoclist . count = cpu_to_le32 ( BRCMF_MAX_ASSOCLIST ); err = brcmf_fil_cmd_data_get ( ifp , BRCMF_C_GET_ASSOCLIST , & cfg -> assoclist , sizeof ( cfg -> assoclist ) ); if ( err )  if ( idx < le32_to_cpu ( cfg -> assoclist . count ) )  return brcmf_cfg80211_get_station ( wiphy , ndev , mac , sinfo ) ; static brcmf_cfg80211_get_station(struct wiphy *wiphy, struct net_device const u8 *mac, struct station_info *sinfo) struct brcmf_if * ifp = netdev_priv ( ndev ) ; struct brcmf_sta_info_le sta_info_le ; if ( ! check_vif_up ( ifp -> vif ) )  static bool check_vif_up(struct brcmf_cfg80211_vif *vif) if ( ! test_bit ( BRCMF_VIF_STATUS_READY , & vif -> sme_state ) )  return false ; return true ; if ( brcmf_is_ibssmode ( ifp -> vif ) )  static bool brcmf_is_ibssmode(struct brcmf_cfg80211_vif *vif) return vif -> wdev . iftype == NL80211_IFTYPE_ADHOC ; memset ( & sta_info_le , 0 , sizeof ( sta_info_le ) ); memcpy ( & sta_info_le , mac , ETH_ALEN ); err = brcmf_fil_iovar_data_get ( ifp , "tdls_sta_info" , & sta_info_le , sizeof ( sta_info_le ) ); is_tdls_peer = ! err; if ( err )  err = brcmf_fil_iovar_data_get ( ifp , "sta_info" , & sta_info_le , sizeof ( sta_info_le ) ); if ( err < 0 )  brcmf_err ( "GET STA INFO failed, %d\n" , err ); brcmf_dbg ( TRACE , "version %d\n" , le16_to_cpu ( sta_info_le . ver ) ); sinfo -> inactive_time = le32_to_cpu ( sta_info_le . idle ) * 1000; sta_flags = le32_to_cpu ( sta_info_le . flags ); brcmf_convert_sta_flags ( sta_flags , sinfo ); static void brcmf_convert_sta_flags(u32 fw_sta_flags, struct station_info *si) brcmf_dbg ( TRACE , "flags %08x\n" , fw_sta_flags ); si -> filled |= BIT ( NL80211_STA_INFO_STA_FLAGS ); sfu = & si -> sta_flags; sfu -> mask = BIT ( NL80211_STA_FLAG_WME ) | BIT ( NL80211_STA_FLAG_AUTHENTICATED ) | BIT ( NL80211_STA_FLAG_ASSOCIATED ) | BIT ( NL80211_STA_FLAG_AUTHORIZED ); if ( fw_sta_flags & BRCMF_STA_WME )  sfu -> set |= BIT ( NL80211_STA_FLAG_WME ); if ( fw_sta_flags & BRCMF_STA_AUTHE )  sfu -> set |= BIT ( NL80211_STA_FLAG_AUTHENTICATED ); if ( fw_sta_flags & BRCMF_STA_ASSOC )  sfu -> set |= BIT ( NL80211_STA_FLAG_ASSOCIATED ); if ( fw_sta_flags & BRCMF_STA_AUTHO )  sfu -> set |= BIT ( NL80211_STA_FLAG_AUTHORIZED ); sinfo -> sta_flags . mask |= BIT ( NL80211_STA_FLAG_TDLS_PEER ); if ( is_tdls_peer )  sinfo -> sta_flags . set |= BIT ( NL80211_STA_FLAG_TDLS_PEER ); sinfo -> sta_flags . set &= ~BIT ( NL80211_STA_FLAG_TDLS_PEER ); if ( sta_flags & BRCMF_STA_ASSOC )  sinfo -> filled |= BIT ( NL80211_STA_INFO_CONNECTED_TIME ); sinfo -> connected_time = le32_to_cpu ( sta_info_le . in ); brcmf_fill_bss_param ( ifp , sinfo ); static void brcmf_fill_bss_param(struct brcmf_if *ifp, struct station_info *si) err = brcmf_fil_cmd_data_get ( ifp , BRCMF_C_GET_BSS_INFO , buf , WL_BSS_INFO_MAX ); if ( err )  brcmf_err ( "Failed to get bss info (%d)\n" , err ); si -> filled |= BIT ( NL80211_STA_INFO_BSS_PARAM ); si -> bss_param . beacon_interval = le16_to_cpu ( buf -> bss_le . beacon_period ); si -> bss_param . dtim_period = buf -> bss_le . dtim_period; si -> bss_param . flags |= BSS_PARAM_FLAGS_CTS_PROT; si -> bss_param . flags |= BSS_PARAM_FLAGS_SHORT_PREAMBLE; si -> bss_param . flags |= BSS_PARAM_FLAGS_SHORT_SLOT_TIME; if ( sta_flags & BRCMF_STA_SCBSTATS )  sinfo -> filled |= BIT ( NL80211_STA_INFO_TX_FAILED ); sinfo -> tx_failed = le32_to_cpu ( sta_info_le . tx_failures ); sinfo -> filled |= BIT ( NL80211_STA_INFO_TX_PACKETS ); sinfo -> tx_packets = le32_to_cpu ( sta_info_le . tx_pkts ); sinfo -> tx_packets += le32_to_cpu ( sta_info_le . tx_mcast_pkts ); sinfo -> filled |= BIT ( NL80211_STA_INFO_RX_PACKETS ); sinfo -> rx_packets = le32_to_cpu ( sta_info_le . rx_ucast_pkts ); sinfo -> rx_packets += le32_to_cpu ( sta_info_le . rx_mcast_pkts ); if ( sinfo -> tx_packets )  sinfo -> filled |= BIT ( NL80211_STA_INFO_TX_BITRATE ); sinfo -> txrate . legacy = le32_to_cpu ( sta_info_le . tx_rate ) / 100; if ( sinfo -> rx_packets )  sinfo -> filled |= BIT ( NL80211_STA_INFO_RX_BITRATE ); sinfo -> rxrate . legacy = le32_to_cpu ( sta_info_le . rx_rate ) / 100; if ( le16_to_cpu ( sta_info_le . ver ) >= 4 )  sinfo -> filled |= BIT ( NL80211_STA_INFO_TX_BYTES ); sinfo -> tx_bytes = le64_to_cpu ( sta_info_le . tx_tot_bytes ); sinfo -> filled |= BIT ( NL80211_STA_INFO_RX_BYTES ); sinfo -> rx_bytes = le64_to_cpu ( sta_info_le . rx_tot_bytes ); if ( sta_info_le . rssi [ i ] )  sinfo -> chain_signal_avg [ count_rssi ] = sta_info_le . rssi [ i ]; sinfo -> chain_signal [ count_rssi ] = sta_info_le . rssi [ i ]; total_rssi += sta_info_le . rssi [ i ]; count_rssi ++; if ( count_rssi )  sinfo -> filled |= BIT ( NL80211_STA_INFO_CHAIN_SIGNAL ); sinfo -> chains = count_rssi; sinfo -> filled |= BIT ( NL80211_STA_INFO_SIGNAL ); total_rssi /= count_rssi; sinfo -> signal = total_rssi; if ( err )  brcmf_err ( "Could not get rssi (%d)\n" , err ); sinfo -> filled |= BIT ( NL80211_STA_INFO_SIGNAL ); sinfo -> signal = rssi; return err ; 