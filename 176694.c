static void build_state(state_num s,struct dfa *d) state_num * trans ; trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) ); while ( 0 )  dfastate ( s , d , trans ); void dfastate(state_num s,struct dfa *d,token trans[]) for (i = 0; i < d -> states[s] . elems . nelem; ++i) pos = d -> states [ s ] . elems . elems [ i ]; if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )  setbit ( d -> tokens [ pos . index ] , matches ); static void setbit(unsigned int b,charclass c) c [ b / ( 8 * sizeof ( int ) ) ] |= 1 << b % ( 8 * sizeof ( int ) ); if ( d -> tokens [ pos . index ] >= CSET )  copyset ( d -> charclasses [ d -> tokens [ pos . index ] - CSET ] , matches ); static void copyset(const int src[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],charclass dst) memcpy ( dst , src , sizeof ( charclass ) ); if ( 1 && ( d -> tokens [ pos . index ] == ANYCHAR || d -> tokens [ pos . index ] == MBCSET ) )  if ( d -> states [ s ] . mbps . nelem == 0 )  alloc_position_set ( & d -> states [ s ] . mbps , 1 ); static void alloc_position_set(position_set *s,size_t size) s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); s -> alloc = size; s -> nelem = 0; insert ( pos , & d -> states [ s ] . mbps ); static void insert(position p,position_set *s) size_t count = s -> nelem ; size_t hi = count ; while ( lo < hi )  size_t mid = lo + hi >> 1 ; if ( s -> elems [ mid ] . index > p . index )  lo = mid + 1; hi = mid; if ( lo < count && p . index == s -> elems [ lo ] . index )  s -> elems [ lo ] . constraint |= p . constraint; if ( s -> alloc <= count + 1 )  size_t new_n_alloc = count + 1 + ( ! s -> elems ) ; s -> elems = ( x2nrealloc ( ( s -> elems ) , & new_n_alloc , sizeof ( ( * s -> elems ) ) ) ); s -> alloc = new_n_alloc; for (i = count; i > lo; i--) s -> elems [ i ] = s -> elems [ i - 1 ]; s -> elems [ lo ] = p; ++ s -> nelem; if ( pos . constraint != 0x777 )  if ( ! ( ( ( ( 4 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  matches [ j ] &= ~newline [ j ]; if ( ! ( ( ( ( 2 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) matches [ j ] &= ~letters [ j ]; if ( ! ( ( ( ( 1 & 1 ? pos . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? pos . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? pos . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context ) )  for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) matches [ j ] &= letters [ j ] | newline [ j ]; for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )) && !matches[j]; ++j) if ( j == ( ( 1 << 8 ) + 8 * sizeof ( int ) - 1 ) / ( 8 * sizeof ( int ) ) )  for (j = 0; j < ngrps; ++j) if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) && ! tstbit ( d -> tokens [ pos . index ] , labels [ j ] ) )  static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; ( intersect [ k ] = matches [ k ] & labels [ j ] [ k ] ) ? ( intersectf = 1 ) : 0; if ( ! intersectf )  for (k = 0; k < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++k) int match = matches [ k ] ; int label = labels [ j ] [ k ] ; ( leftovers [ k ] = ~match & label ) ? ( leftoversf = 1 ) : 0; ( matches [ k ] = match & ~label ) ? ( matchesf = 1 ) : 0; if ( leftoversf )  copyset ( leftovers , labels [ ngrps ] ); static void copyset(const int src[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],charclass dst) memcpy ( dst , src , sizeof ( charclass ) ); copyset ( intersect , labels [ j ] ); static void copyset(const int src[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],charclass dst) memcpy ( dst , src , sizeof ( charclass ) ); grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); memcpy ( grps [ ngrps ] . elems , grps [ j ] . elems , sizeof ( grps [ j ] . elems [ 0 ] ) * grps [ j ] . nelem ); grps [ ngrps ] . nelem = grps [ j ] . nelem; grps [ j ] . elems [ grps [ j ] . nelem ++ ] = pos . index; if ( ! matchesf )  if ( j == ngrps )  copyset ( matches , labels [ ngrps ] ); static void copyset(const int src[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],charclass dst) memcpy ( dst , src , sizeof ( charclass ) ); zeroset ( matches ); static void zeroset(charclass s) memset ( s , 0 , sizeof ( charclass ) ); grps [ ngrps ] . elems = ( ( sizeof ( ( * grps [ ngrps ] . elems ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * grps [ ngrps ] . elems ) ) ) ) ); grps [ ngrps ] . nelem = 1; grps [ ngrps ] . elems [ 0 ] = pos . index; alloc_position_set ( & follows , d -> nleaves ); static void alloc_position_set(position_set *s,size_t size) s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); s -> alloc = size; s -> nelem = 0; alloc_position_set ( & tmp , d -> nleaves ); static void alloc_position_set(position_set *s,size_t size) s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); s -> alloc = size; s -> nelem = 0; if ( d -> searchflag )  copy ( ( & d -> states [ 0 ] . elems ) , & follows ); static void copy(const position_set *src,position_set *dst) if ( dst -> alloc <= src -> nelem )  size_t new_n_alloc = src -> nelem + ( ! dst -> elems ) ; dst -> elems = ( x2nrealloc ( ( dst -> elems ) , & new_n_alloc , sizeof ( ( * dst -> elems ) ) ) ); dst -> alloc = new_n_alloc; memcpy ( ( dst -> elems ) , ( src -> elems ) , sizeof ( dst -> elems [ 0 ] ) * src -> nelem ); dst -> nelem = src -> nelem; state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); static state_num state_index(struct dfa *d,const position_set *s,int context) for (i = 0; i < s -> nelem; ++i) hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; for (i = 0; i < d -> sindex; ++i) if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  for (j = 0; j < s -> nelem; ++j) if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  if ( j == s -> nelem )  if ( d -> salloc <= d -> sindex + 1 )  size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); d -> salloc = new_n_alloc; d -> states [ i ] . hash = hash; alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); static void alloc_position_set(position_set *s,size_t size) s -> elems = ( ( sizeof ( ( * s -> elems ) ) == 1 ? xmalloc ( size ) : xnmalloc ( size , sizeof ( ( * s -> elems ) ) ) ) ); s -> alloc = size; s -> nelem = 0; copy ( s , & d -> states [ i ] . elems ); static void copy(const position_set *src,position_set *dst) if ( dst -> alloc <= src -> nelem )  size_t new_n_alloc = src -> nelem + ( ! dst -> elems ) ; dst -> elems = ( x2nrealloc ( ( dst -> elems ) , & new_n_alloc , sizeof ( ( * dst -> elems ) ) ) ); dst -> alloc = new_n_alloc; memcpy ( ( dst -> elems ) , ( src -> elems ) , sizeof ( dst -> elems [ 0 ] ) * src -> nelem ); dst -> nelem = src -> nelem; d -> states [ i ] . context = context; d -> states [ i ] . backref = 0; d -> states [ i ] . constraint = 0; d -> states [ i ] . first_end = 0; d -> states [ i ] . mbps . nelem = 0; d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); for (j = 0; j < s -> nelem; ++j) if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  constraint = s -> elems [ j ] . constraint; if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  d -> states [ i ] . constraint |= constraint; if ( ! d -> states [ i ] . first_end )  d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  d -> states [ i ] . constraint = 0x777; d -> states [ i ] . backref = 1; ++ d -> sindex; return i ; state_newline = state_index ( d , ( & follows ) , 4 ); static state_num state_index(struct dfa *d,const position_set *s,int context) hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  if ( j == s -> nelem )  if ( d -> salloc <= d -> sindex + 1 )  size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); d -> salloc = new_n_alloc; d -> states [ i ] . hash = hash; alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); copy ( s , & d -> states [ i ] . elems ); d -> states [ i ] . context = context; d -> states [ i ] . backref = 0; d -> states [ i ] . constraint = 0; d -> states [ i ] . first_end = 0; d -> states [ i ] . mbps . nelem = 0; d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  constraint = s -> elems [ j ] . constraint; if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  d -> states [ i ] . constraint |= constraint; if ( ! d -> states [ i ] . first_end )  d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  d -> states [ i ] . constraint = 0x777; d -> states [ i ] . backref = 1; ++ d -> sindex; return i ; state_newline = state; state_letter = state_index ( d , ( & follows ) , 2 ); static state_num state_index(struct dfa *d,const position_set *s,int context) hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  if ( j == s -> nelem )  if ( d -> salloc <= d -> sindex + 1 )  size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); d -> salloc = new_n_alloc; d -> states [ i ] . hash = hash; alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); copy ( s , & d -> states [ i ] . elems ); d -> states [ i ] . context = context; d -> states [ i ] . backref = 0; d -> states [ i ] . constraint = 0; d -> states [ i ] . first_end = 0; d -> states [ i ] . mbps . nelem = 0; d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  constraint = s -> elems [ j ] . constraint; if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  d -> states [ i ] . constraint |= constraint; if ( ! d -> states [ i ] . first_end )  d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  d -> states [ i ] . constraint = 0x777; d -> states [ i ] . backref = 1; ++ d -> sindex; return i ; state_letter = state; trans [ i ] = ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) i ] & ( ( unsigned short ) _ISalnum ) || i == '_' ) ? state_letter : state ); trans [ eolbyte ] = state_newline; trans [ i ] = ( - 1 ); for (i = 0; i < ngrps; ++i) for (j = 0; j < grps[i] . nelem; ++j) for (k = 0; k < d -> follows[grps[i] . elems[j]] . nelem; ++k) insert ( d -> follows [ grps [ i ] . elems [ j ] ] . elems [ k ] , & follows ); static void insert(position p,position_set *s) size_t count = s -> nelem ; size_t hi = count ; while ( lo < hi )  size_t mid = lo + hi >> 1 ; if ( s -> elems [ mid ] . index > p . index )  lo = mid + 1; hi = mid; if ( lo < count && p . index == s -> elems [ lo ] . index )  s -> elems [ lo ] . constraint |= p . constraint; if ( s -> alloc <= count + 1 )  size_t new_n_alloc = count + 1 + ( ! s -> elems ) ; s -> elems = ( x2nrealloc ( ( s -> elems ) , & new_n_alloc , sizeof ( ( * s -> elems ) ) ) ); s -> alloc = new_n_alloc; s -> elems [ i ] = s -> elems [ i - 1 ]; s -> elems [ lo ] = p; ++ s -> nelem; if ( d -> mb_cur_max > 1 )  for (j = 0; j < follows . nelem; ++j) if ( ! ( d -> multibyte_prop [ follows . elems [ j ] . index ] & 1 ) )  if ( d -> searchflag && ( ! 1 || ( d -> mb_cur_max == 1 || ! next_isnt_1st_byte ) ) )  for (j = 0; j < d -> states[0] . elems . nelem; ++j) insert ( d -> states [ 0 ] . elems . elems [ j ] , & follows ); static void insert(position p,position_set *s) size_t count = s -> nelem ; size_t hi = count ; while ( lo < hi )  size_t mid = lo + hi >> 1 ; if ( s -> elems [ mid ] . index > p . index )  lo = mid + 1; hi = mid; if ( lo < count && p . index == s -> elems [ lo ] . index )  s -> elems [ lo ] . constraint |= p . constraint; if ( s -> alloc <= count + 1 )  size_t new_n_alloc = count + 1 + ( ! s -> elems ) ; s -> elems = ( x2nrealloc ( ( s -> elems ) , & new_n_alloc , sizeof ( ( * s -> elems ) ) ) ); s -> alloc = new_n_alloc; s -> elems [ i ] = s -> elems [ i - 1 ]; s -> elems [ lo ] = p; ++ s -> nelem; possible_contexts = charclass_context ( labels [ i ] ); static int charclass_context(charclass c) if ( tstbit ( eolbyte , c ) )  static int tstbit(unsigned int b,const int c[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))]) return c [ b / ( 8 * sizeof ( int ) ) ] & 1 << b % ( 8 * sizeof ( int ) ) ; if ( c [ j ] & letters [ j ] )  if ( c [ j ] & ~ ( letters [ j ] | newline [ j ] ) )  if ( ( separate_contexts & possible_contexts ) != possible_contexts )  state = state_index ( d , ( & follows ) , separate_contexts ^ 7 ); static state_num state_index(struct dfa *d,const position_set *s,int context) hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  if ( j == s -> nelem )  if ( d -> salloc <= d -> sindex + 1 )  size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); d -> salloc = new_n_alloc; d -> states [ i ] . hash = hash; alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); copy ( s , & d -> states [ i ] . elems ); d -> states [ i ] . context = context; d -> states [ i ] . backref = 0; d -> states [ i ] . constraint = 0; d -> states [ i ] . first_end = 0; d -> states [ i ] . mbps . nelem = 0; d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  constraint = s -> elems [ j ] . constraint; if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  d -> states [ i ] . constraint |= constraint; if ( ! d -> states [ i ] . first_end )  d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  d -> states [ i ] . constraint = 0x777; d -> states [ i ] . backref = 1; ++ d -> sindex; return i ; if ( separate_contexts & possible_contexts & 4 )  state_newline = state_index ( d , ( & follows ) , 4 ); static state_num state_index(struct dfa *d,const position_set *s,int context) hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  if ( j == s -> nelem )  if ( d -> salloc <= d -> sindex + 1 )  size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); d -> salloc = new_n_alloc; d -> states [ i ] . hash = hash; alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); copy ( s , & d -> states [ i ] . elems ); d -> states [ i ] . context = context; d -> states [ i ] . backref = 0; d -> states [ i ] . constraint = 0; d -> states [ i ] . first_end = 0; d -> states [ i ] . mbps . nelem = 0; d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  constraint = s -> elems [ j ] . constraint; if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  d -> states [ i ] . constraint |= constraint; if ( ! d -> states [ i ] . first_end )  d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  d -> states [ i ] . constraint = 0x777; d -> states [ i ] . backref = 1; ++ d -> sindex; return i ; state_newline = state; if ( separate_contexts & possible_contexts & 2 )  state_letter = state_index ( d , ( & follows ) , 2 ); static state_num state_index(struct dfa *d,const position_set *s,int context) hash ^= s -> elems [ i ] . index + s -> elems [ i ] . constraint; if ( hash != d -> states [ i ] . hash || s -> nelem != d -> states [ i ] . elems . nelem || context != d -> states [ i ] . context )  if ( s -> elems [ j ] . constraint != d -> states [ i ] . elems . elems [ j ] . constraint || s -> elems [ j ] . index != d -> states [ i ] . elems . elems [ j ] . index )  if ( j == s -> nelem )  if ( d -> salloc <= d -> sindex + 1 )  size_t new_n_alloc = ( d -> sindex + 1 + ( ! d -> states ) ) ; d -> states = ( x2nrealloc ( ( d -> states ) , & new_n_alloc , sizeof ( ( * d -> states ) ) ) ); d -> salloc = new_n_alloc; d -> states [ i ] . hash = hash; alloc_position_set ( & d -> states [ i ] . elems , s -> nelem ); copy ( s , & d -> states [ i ] . elems ); d -> states [ i ] . context = context; d -> states [ i ] . backref = 0; d -> states [ i ] . constraint = 0; d -> states [ i ] . first_end = 0; d -> states [ i ] . mbps . nelem = 0; d -> states [ i ] . mbps . elems = ( ( void * ) 0 ); if ( d -> tokens [ s -> elems [ j ] . index ] < 0 )  constraint = s -> elems [ j ] . constraint; if ( ( ( ( 7 & 1 ? constraint & 0xf : 0 ) ) | ( ( 7 & 2 ? constraint >> 4 & 0xf : 0 ) ) | ( ( 7 & 4 ? constraint >> 8 & 0xf : 0 ) ) ) & context )  d -> states [ i ] . constraint |= constraint; if ( ! d -> states [ i ] . first_end )  d -> states [ i ] . first_end = d -> tokens [ s -> elems [ j ] . index ]; if ( d -> tokens [ s -> elems [ j ] . index ] == BACKREF )  d -> states [ i ] . constraint = 0x777; d -> states [ i ] . backref = 1; ++ d -> sindex; return i ; state_letter = state; for (j = 0; j < ((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int )); ++j) for (k = 0; k < 8 * sizeof(int ); ++k) if ( labels [ i ] [ j ] & 1 << k )  int c = ( j * ( 8 * sizeof ( int ) ) + k ) ; if ( c == eolbyte )  trans [ c ] = state_newline; if ( 1 && ( ( * __ctype_b_loc ( ) ) [ ( int ) c ] & ( ( unsigned short ) _ISalnum ) || c == '_' ) )  trans [ c ] = state_letter; if ( c < 1 << 8 )  trans [ c ] = state; for (i = 0; i < ngrps; ++i) free ( grps [ i ] . elems ); free ( grps ); if ( trans [ i ] >= d -> tralloc )  while ( trans [ i ] >= d -> tralloc )  d -> newlines [ s ] = trans [ eolbyte ]; trans [ eolbyte ] = ( - 1 ); if ( ( * d ) . states [ s ] . constraint )  d -> fails [ s ] = trans; d -> trans [ s ] = trans; 