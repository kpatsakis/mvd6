static void md_common_write(void *opaque, uint32_t at, uint16_t value) struct md_s * s = ( struct md_s * ) opaque ; at -= s -> io_base; switch ( s -> opt & OPT_MODE )  if ( ( at & ~0x3ff ) == 0x400 )  at = 0; at &= 0xf; if ( ( at & ~0xf ) == 0x3f0 )  at -= 0x3e8; if ( ( at & ~0xf ) == 0x1f0 )  at -= 0x1f0; if ( ( at & ~0xf ) == 0x370 )  at -= 0x368; if ( ( at & ~0xf ) == 0x170 )  at -= 0x170; switch ( at )  if ( s -> cycle )  s -> io = value & 0xff; s -> cycle = ! s -> cycle; s -> io = value & 0xff; s -> cycle = ! s -> cycle; ide_ioport_write ( s -> ide , 0x1 , value ); static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val) IDEState * ide_if = opaque ; IDEState * s ; int unit , n ; addr &= 7; if ( addr != 7 && ( ide_if -> cur_drive -> status & ( BUSY_STAT | DRQ_STAT ) ) )  switch ( addr )  ide_if [ 0 ] . hob_feature = ide_if [ 0 ] . feature; ide_if [ 1 ] . hob_feature = ide_if [ 1 ] . feature; ide_if [ 0 ] . feature = val; ide_if [ 1 ] . feature = val; ide_if [ 0 ] . hob_nsector = ide_if [ 0 ] . nsector; ide_if [ 1 ] . hob_nsector = ide_if [ 1 ] . nsector; ide_if [ 0 ] . nsector = val; ide_if [ 1 ] . nsector = val; ide_if [ 0 ] . hob_sector = ide_if [ 0 ] . sector; ide_if [ 1 ] . hob_sector = ide_if [ 1 ] . sector; ide_if [ 0 ] . sector = val; ide_if [ 1 ] . sector = val; ide_if [ 0 ] . hob_lcyl = ide_if [ 0 ] . lcyl; ide_if [ 1 ] . hob_lcyl = ide_if [ 1 ] . lcyl; ide_if [ 0 ] . lcyl = val; ide_if [ 1 ] . lcyl = val; ide_if [ 0 ] . hob_hcyl = ide_if [ 0 ] . hcyl; ide_if [ 1 ] . hob_hcyl = ide_if [ 1 ] . hcyl; ide_if [ 0 ] . hcyl = val; ide_if [ 1 ] . hcyl = val; ide_if [ 0 ] . select = ( val & ~0x10 ) | 0xa0; ide_if [ 1 ] . select = ( val | 0x10 ) | 0xa0; unit = ( val >> 4 ) & 1; s = ide_if + unit; ide_if -> cur_drive = s; s = ide_if -> cur_drive; if ( ! s -> bs )  if ( ( s -> status & ( BUSY_STAT | DRQ_STAT ) ) && val != WIN_DEVICE_RESET )  switch ( val )  if ( ! s -> is_cf )  s -> error = 0x09; s -> status = READY_STAT | SEEK_STAT; if ( ! s -> is_cf )  if ( val == CFA_WEAR_LEVEL )  s -> nsector = 0; if ( val == CFA_ERASE_SECTORS )  s -> media_changed = 1; s -> error = 0x00; s -> status = READY_STAT | SEEK_STAT; if ( ! s -> is_cf )  s -> error = 0x00; s -> status = READY_STAT | SEEK_STAT; memset ( s -> io_buffer , 0 , 0x200 ); s -> io_buffer [ 0x00 ] = s -> hcyl; s -> io_buffer [ 0x01 ] = s -> lcyl; s -> io_buffer [ 0x02 ] = s -> select; s -> io_buffer [ 0x03 ] = s -> sector; s -> io_buffer [ 0x04 ] = ide_get_sector ( s ) >> 16; static int64_t ide_get_sector(IDEState *s) if ( s -> select & 0x40 )  if ( ! s -> lba48 )  sector_num = ( ( s -> select & 0x0f ) << 24 ) | ( s -> hcyl << 16 ) | ( s -> lcyl << 8 ) | s -> sector; sector_num = ( ( int64_t ) s -> hob_hcyl << 40 ) | ( ( int64_t ) s -> hob_lcyl << 32 ) | ( ( int64_t ) s -> hob_sector << 24 ) | ( ( int64_t ) s -> hcyl << 16 ) | ( ( int64_t ) s -> lcyl << 8 ) | s -> sector; sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 ); return sector_num ; s -> io_buffer [ 0x05 ] = ide_get_sector ( s ) >> 8; static int64_t ide_get_sector(IDEState *s) if ( s -> select & 0x40 )  if ( ! s -> lba48 )  sector_num = ( ( s -> select & 0x0f ) << 24 ) | ( s -> hcyl << 16 ) | ( s -> lcyl << 8 ) | s -> sector; sector_num = ( ( int64_t ) s -> hob_hcyl << 40 ) | ( ( int64_t ) s -> hob_lcyl << 32 ) | ( ( int64_t ) s -> hob_sector << 24 ) | ( ( int64_t ) s -> hcyl << 16 ) | ( ( int64_t ) s -> lcyl << 8 ) | s -> sector; sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 ); return sector_num ; s -> io_buffer [ 0x06 ] = ide_get_sector ( s ) >> 0; static int64_t ide_get_sector(IDEState *s) if ( s -> select & 0x40 )  if ( ! s -> lba48 )  sector_num = ( ( s -> select & 0x0f ) << 24 ) | ( s -> hcyl << 16 ) | ( s -> lcyl << 8 ) | s -> sector; sector_num = ( ( int64_t ) s -> hob_hcyl << 40 ) | ( ( int64_t ) s -> hob_lcyl << 32 ) | ( ( int64_t ) s -> hob_sector << 24 ) | ( ( int64_t ) s -> hcyl << 16 ) | ( ( int64_t ) s -> lcyl << 8 ) | s -> sector; sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 ); return sector_num ; s -> io_buffer [ 0x13 ] = 0x00; s -> io_buffer [ 0x18 ] = 0x00; s -> io_buffer [ 0x19 ] = 0x00; s -> io_buffer [ 0x1a ] = 0x01; ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop ); static void ide_transfer_start(IDEState *s, uint8_t *buf, int EndTransferFunc *end_transfer_func) s -> end_transfer_func = end_transfer_func; s -> data_ptr = buf; s -> data_end = buf + size; if ( ! ( s -> status & ERR_STAT ) )  s -> status |= DRQ_STAT; buffered_pio_reset ( s ); static inline buffered_pio_reset(IDEState *s) if ( ( unsigned ) s -> drive_serial - 1 < 2 )  if ( ( unsigned ) s -> drive_serial - 3 < 2 )  ide_set_irq ( s ); static inline void ide_set_irq(IDEState *s) BMDMAState * bm = s -> bmdma ; if ( ! s -> bs )  if ( ! ( s -> cmd & IDE_CMD_DISABLE_IRQ ) )  if ( bm )  bm -> status |= BM_STATUS_INT; qemu_irq_raise ( s -> irq ); if ( ! s -> is_cf )  switch ( s -> feature )  ide_cfata_metadata_inquiry ( s ); static void ide_cfata_metadata_inquiry(IDEState *s) p = ( uint16_t * ) s -> io_buffer; memset ( p , 0 , 0x200 ); spd = ( ( s -> mdata_size - 1 ) >> 9 ) + 1; put_le16 ( p + 0 , 0x0001 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 1 , 0x0000 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 2 , s -> media_changed ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 3 , s -> mdata_size & 0xffff ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 4 , s -> mdata_size >> 16 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 5 , spd & 0xffff ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); put_le16 ( p + 6 , spd >> 16 ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); ide_cfata_metadata_read ( s ); static void ide_cfata_metadata_read(IDEState *s) if ( ( ( s -> hcyl << 16 ) | s -> lcyl ) << 9 > s -> mdata_size + 2 )  s -> status = ERR_STAT; s -> error = ABRT_ERR; p = ( uint16_t * ) s -> io_buffer; memset ( p , 0 , 0x200 ); put_le16 ( p + 0 , s -> media_changed ); static void put_le16(uint16_t *p, unsigned int v) * p = cpu_to_le16 ( v ); memcpy ( p + 1 , s -> mdata_storage + ( ( ( s -> hcyl << 16 ) | s -> lcyl ) << 9 ) , MIN ( MIN ( s -> mdata_size - ( ( ( s -> hcyl << 16 ) | s -> lcyl ) << 9 ) , s -> nsector << 9 ) , 0x200 - 2 ) ); ide_cfata_metadata_write ( s ); static void ide_cfata_metadata_write(IDEState *s) if ( ( ( s -> hcyl << 16 ) | s -> lcyl ) << 9 > s -> mdata_size + 2 )  s -> status = ERR_STAT; s -> error = ABRT_ERR; s -> media_changed = 0; memcpy ( s -> mdata_storage + ( ( ( s -> hcyl << 16 ) | s -> lcyl ) << 9 ) , s -> io_buffer + 2 , MIN ( MIN ( s -> mdata_size - ( ( ( s -> hcyl << 16 ) | s -> lcyl ) << 9 ) , s -> nsector << 9 ) , 0x200 - 2 ) ); ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop ); static void ide_transfer_start(IDEState *s, uint8_t *buf, int EndTransferFunc *end_transfer_func) s -> end_transfer_func = end_transfer_func; s -> data_ptr = buf; s -> data_end = buf + size; if ( ! ( s -> status & ERR_STAT ) )  s -> status |= DRQ_STAT; buffered_pio_reset ( s ); s -> status = 0x00; ide_set_irq ( s ); static inline void ide_set_irq(IDEState *s) BMDMAState * bm = s -> bmdma ; if ( ! s -> bs )  if ( ! ( s -> cmd & IDE_CMD_DISABLE_IRQ ) )  if ( bm )  bm -> status |= BM_STATUS_INT; qemu_irq_raise ( s -> irq ); 