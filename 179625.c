static int aes_gcm_ctrl(EVP_CIPHER_CTX *c,int type,int arg,void *ptr) EVP_AES_GCM_CTX * gctx = ( c -> cipher_data ) ; switch ( type )  gctx -> key_set = 0; gctx -> iv_set = 0; gctx -> ivlen = c -> cipher -> iv_len; gctx -> iv = c -> iv; gctx -> taglen = - 1; gctx -> iv_gen = 0; gctx -> tls_aad_len = - 1; if ( arg <= 0 )  if ( arg > 16 && arg > gctx -> ivlen )  gctx -> iv = ( CRYPTO_malloc ( ( ( int ) arg ) , "e_aes.c" , 728 ) ); if ( ! gctx -> iv )  gctx -> ivlen = arg; if ( arg <= 0 || arg > 16 || c -> encrypt )  memcpy ( ( c -> buf ) , ptr , arg ); gctx -> taglen = arg; if ( arg <= 0 || arg > 16 || ! c -> encrypt || gctx -> taglen < 0 )  memcpy ( ptr , ( c -> buf ) , arg ); if ( arg == - 1 )  if ( arg < 4 || gctx -> ivlen - arg < 8 )  if ( arg )  memcpy ( ( gctx -> iv ) , ptr , arg ); if ( c -> encrypt && RAND_bytes ( gctx -> iv + arg , gctx -> ivlen - arg ) <= 0 )  gctx -> iv_gen = 1; if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 )  CRYPTO_gcm128_setiv ( & gctx -> gcm , ( gctx -> iv ) , ( gctx -> ivlen ) ); if ( arg <= 0 || arg > gctx -> ivlen )  arg = gctx -> ivlen; memcpy ( ptr , ( gctx -> iv + gctx -> ivlen - arg ) , arg ); ctr64_inc ( gctx -> iv + gctx -> ivlen - 8 ); static void ctr64_inc(unsigned char *counter) c = counter [ n ]; counter [ n ] = c; if ( c )  while ( n )  gctx -> iv_set = 1; if ( gctx -> iv_gen == 0 || gctx -> key_set == 0 || c -> encrypt )  memcpy ( ( gctx -> iv + gctx -> ivlen - arg ) , ptr , arg ); CRYPTO_gcm128_setiv ( & gctx -> gcm , ( gctx -> iv ) , ( gctx -> ivlen ) ); gctx -> iv_set = 1; if ( arg != 13 )  memcpy ( ( c -> buf ) , ptr , arg ); gctx -> tls_aad_len = arg; unsigned int len = ( c -> buf [ arg - 2 ] << 8 | c -> buf [ arg - 1 ] ) ; len -= 8; if ( ! c -> encrypt )  len -= 16; c -> buf [ arg - 2 ] = ( len >> 8 ); c -> buf [ arg - 1 ] = ( len & 0xff ); 