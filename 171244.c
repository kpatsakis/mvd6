static void xhci_doorbell_write(void *ptr, hwaddr uint64_t val, unsigned size) XHCIState * xhci = ptr ; if ( ! xhci_running ( xhci ) )  reg >>= 2; if ( reg == 0 )  if ( val == 0 )  xhci_process_commands ( xhci ); static void xhci_process_commands(XHCIState *xhci) XHCITRB trb ; TRBType type ; XHCIEvent event = { ER_COMMAND_COMPLETE , CC_SUCCESS } ; dma_addr_t addr ; unsigned int i , slotid = 0 ; if ( ! xhci_running ( xhci ) )  xhci -> crcr_low |= CRCR_CRR; while ( type = xhci_ring_fetch ( xhci , & xhci -> cmd_ring , & trb , & addr ) )  event . ptr = addr; switch ( type )  for (i = 0; i < xhci->numslots; i++) if ( ! xhci -> slots [ i ] . enabled )  if ( i >= xhci -> numslots )  event . ccode = CC_NO_SLOTS_ERROR; slotid = i + 1; event . ccode = xhci_enable_slot ( xhci , slotid ); slotid = xhci_get_slot ( xhci , & event , & trb ); if ( slotid )  event . ccode = xhci_disable_slot ( xhci , slotid ); slotid = xhci_get_slot ( xhci , & event , & trb ); if ( slotid )  event . ccode = xhci_address_slot ( xhci , slotid , trb . parameter , trb . control & TRB_CR_BSR ); slotid = xhci_get_slot ( xhci , & event , & trb ); if ( slotid )  event . ccode = xhci_configure_slot ( xhci , slotid , trb . parameter , trb . control & TRB_CR_DC ); slotid = xhci_get_slot ( xhci , & event , & trb ); if ( slotid )  event . ccode = xhci_evaluate_slot ( xhci , slotid , trb . parameter ); slotid = xhci_get_slot ( xhci , & event , & trb ); if ( slotid )  unsigned int epid = ( trb . control >> TRB_CR_EPID_SHIFT ) & TRB_CR_EPID_MASK ; event . ccode = xhci_stop_ep ( xhci , slotid , epid ); slotid = xhci_get_slot ( xhci , & event , & trb ); if ( slotid )  unsigned int epid = ( trb . control >> TRB_CR_EPID_SHIFT ) & TRB_CR_EPID_MASK ; event . ccode = xhci_reset_ep ( xhci , slotid , epid ); slotid = xhci_get_slot ( xhci , & event , & trb ); if ( slotid )  unsigned int epid = ( trb . control >> TRB_CR_EPID_SHIFT ) & TRB_CR_EPID_MASK ; unsigned int streamid = ( trb . status >> 16 ) & 0xffff ; event . ccode = xhci_set_ep_dequeue ( xhci , slotid , epid , streamid , trb . parameter ); slotid = xhci_get_slot ( xhci , & event , & trb ); if ( slotid )  event . ccode = xhci_reset_slot ( xhci , slotid ); event . ccode = xhci_get_port_bandwidth ( xhci , trb . parameter ); event . type = 48; event . length = 0x3025; uint32_t chi = trb . parameter >> 32 ; uint32_t clo = trb . parameter ; uint32_t val = xhci_nec_challenge ( chi , clo ) ; event . length = val & 0xFFFF; event . epid = val >> 16; slotid = val >> 24; event . type = 48; event . ccode = CC_TRB_ERROR; event . slotid = slotid; static TRBCCode xhci_configure_slot(XHCIState *xhci, unsigned int uint64_t pictx, bool dc) dma_addr_t ictx , octx ; uint32_t ictl_ctx [ 2 ] ; uint32_t slot_ctx [ 4 ] ; uint32_t ep_ctx [ 5 ] ; int i ; TRBCCode res ; octx = xhci -> slots [ slotid - 1 ] . ctx; if ( dc )  if ( ( ictl_ctx [ 0 ] & 0x3 ) != 0x0 || ( ictl_ctx [ 1 ] & 0x3 ) != 0x1 )  if ( SLOT_STATE ( slot_ctx [ 3 ] ) < SLOT_ADDRESSED )  for (i = 2; i <= 31; i++) if ( ictl_ctx [ 1 ] & ( 1 << i ) )  res = xhci_enable_ep ( xhci , slotid , i , octx + ( 32 * i ) , ep_ctx ); if ( res != CC_SUCCESS )  res = xhci_alloc_device_streams ( xhci , slotid , ictl_ctx [ 1 ] ); static TRBCCode xhci_alloc_device_streams(XHCIState *xhci, unsigned int uint32_t epmask) XHCIEPContext * epctxs [ 30 ] ; USBEndpoint * eps [ 30 ] ; int i , r , nr_eps , req_nr_streams , dev_max_streams ; nr_eps = xhci_epmask_to_eps_with_streams ( xhci , slotid , epmask , epctxs , eps ); static int xhci_epmask_to_eps_with_streams(XHCIState unsigned int uint32_t XHCIEPContext USBEndpoint **eps) XHCISlot * slot ; XHCIEPContext * epctx ; USBEndpoint * ep ; int i , j ; slot = & xhci -> slots [ slotid - 1 ]; for (i = 2, j = 0; i <= 31; i++) if ( ! ( epmask & ( 1u << i ) ) )  epctx = slot -> eps [ i - 1 ]; ep = xhci_epid_to_usbep ( xhci , slotid , i ); static USBEndpoint *xhci_epid_to_usbep(XHCIState unsigned int slotid, unsigned int epid) if ( ! xhci -> slots [ slotid - 1 ] . uport )  return NULL ; return usb_ep_get ( xhci -> slots [ slotid - 1 ] . uport -> dev , ( epid & 1 ) ? USB_TOKEN_IN : USB_TOKEN_OUT , epid >> 1 ) ; if ( ! epctx || ! epctx -> nr_pstreams || ! ep )  if ( epctxs )  epctxs [ j ] = epctx; eps [ j ++ ] = ep; return j ; if ( nr_eps == 0 )  return CC_SUCCESS ; req_nr_streams = epctxs [ 0 ] -> nr_pstreams; dev_max_streams = eps [ 0 ] -> max_streams; for (i = 1; i < nr_eps; i++) if ( epctxs [ i ] -> nr_pstreams != req_nr_streams )  return CC_RESOURCE_ERROR ; if ( eps [ i ] -> max_streams != dev_max_streams )  return CC_RESOURCE_ERROR ; if ( req_nr_streams > dev_max_streams )  req_nr_streams = dev_max_streams; r = usb_device_alloc_streams ( eps [ 0 ] -> dev , eps , nr_eps , req_nr_streams ); if ( r != 0 )  return CC_RESOURCE_ERROR ; return CC_SUCCESS ; if ( res != CC_SUCCESS )  for (i = 2; i <= 31; i++) if ( ictl_ctx [ 1 ] & ( 1u << i ) )  xhci_disable_ep ( xhci , slotid , i ); static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int unsigned int epid) assert ( slotid >= 1 && slotid <= xhci -> numslots ); 