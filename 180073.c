static void fdctrl_start_transfer(FDCtrl *fdctrl, int direction) FDrive * cur_drv ; uint8_t kh , kt , ks ; cur_drv = get_cur_drv ( fdctrl ); static FDrive *get_cur_drv(FDCtrl *fdctrl) switch ( fdctrl -> cur_drv )  return drv0 ( fdctrl ) ; static inline FDrive *drv0(FDCtrl *fdctrl) return & fdctrl -> drives [ ( fdctrl -> tdr & FD_TDR_BOOTSEL ) >> 2 ] ; return drv1 ( fdctrl ) ; static inline FDrive *drv1(FDCtrl *fdctrl) if ( ( fdctrl -> tdr & FD_TDR_BOOTSEL ) < ( 1 << 2 ) )  return & fdctrl -> drives [ 1 ] ; return & fdctrl -> drives [ 0 ] ; return drv2 ( fdctrl ) ; static inline FDrive *drv2(FDCtrl *fdctrl) if ( ( fdctrl -> tdr & FD_TDR_BOOTSEL ) < ( 2 << 2 ) )  return & fdctrl -> drives [ 2 ] ; return & fdctrl -> drives [ 1 ] ; return drv3 ( fdctrl ) ; static inline FDrive *drv3(FDCtrl *fdctrl) if ( ( fdctrl -> tdr & FD_TDR_BOOTSEL ) < ( 3 << 2 ) )  return & fdctrl -> drives [ 3 ] ; return & fdctrl -> drives [ 2 ] ; return NULL ; kt = fdctrl -> fifo [ 2 ]; kh = fdctrl -> fifo [ 3 ]; ks = fdctrl -> fifo [ 4 ]; switch ( fd_seek ( cur_drv , kh , kt , ks , fdctrl -> config & FD_CONFIG_EIS ) )  static int fd_seek(FDrive *drv, uint8_t head, uint8_t track, uint8_t int enable_seek) uint32_t sector ; int ret ; if ( track > drv -> max_track || ( head != 0 && ( drv -> flags & FDISK_DBL_SIDES ) == 0 ) )  return 2 ; if ( sect > drv -> last_sect )  return 3 ; sector = fd_sector_calc ( head , track , sect , drv -> last_sect , NUM_SIDES ( drv ) ); static int fd_sector_calc(uint8_t head, uint8_t track, uint8_t uint8_t last_sect, uint8_t num_sides) return ( ( ( track * num_sides ) + head ) * last_sect ) + sect - 1 ; ret = 0; if ( sector != fd_sector ( drv ) )  static int fd_sector(FDrive *drv) return fd_sector_calc ( drv -> head , drv -> track , drv -> sect , drv -> last_sect , NUM_SIDES ( drv ) ) ; static int fd_sector_calc(uint8_t head, uint8_t track, uint8_t uint8_t last_sect, uint8_t num_sides) return ( ( ( track * num_sides ) + head ) * last_sect ) + sect - 1 ; if ( ! enable_seek )  return 4 ; drv -> head = head; if ( drv -> track != track )  if ( drv -> blk != NULL && blk_is_inserted ( drv -> blk ) )  drv -> media_changed = 0; ret = 1; drv -> track = track; drv -> sect = sect; if ( drv -> blk == NULL || ! blk_is_inserted ( drv -> blk ) )  ret = 2; return ret ; fdctrl -> fifo [ 3 ] = kt; fdctrl -> fifo [ 4 ] = kh; fdctrl -> fifo [ 5 ] = ks; fdctrl -> fifo [ 3 ] = kt; fdctrl -> fifo [ 4 ] = kh; fdctrl -> fifo [ 5 ] = ks; fdctrl -> fifo [ 3 ] = kt; fdctrl -> fifo [ 4 ] = kh; fdctrl -> fifo [ 5 ] = ks; fdctrl -> status0 |= FD_SR0_SEEK; if ( fdctrl -> check_media_rate && ( fdctrl -> dsr & FD_DSR_DRATEMASK ) != cur_drv -> media_rate )  fdctrl -> data_dir = direction; fdctrl -> data_pos = 0; assert ( fdctrl -> msr & FD_MSR_CMDBUSY ); 