int avcodec_encode_audio(AVCodecContext *avctx,uint8_t *buf,int buf_size,const short *samples) AVPacket pkt ; AVFrame * frame ; int ret ; int samples_size ; int got_packet ; pkt . data = buf; pkt . size = buf_size; if ( samples )  frame = & frame0; if ( avctx -> frame_size )  frame -> nb_samples = avctx -> frame_size; int64_t nb_samples ; if ( ! av_get_bits_per_sample ( avctx -> codec_id ) )  int av_get_bits_per_sample(enum AVCodecID codec_id) switch ( codec_id )  return 2 ; return 3 ; return 4 ; return av_get_exact_bits_per_sample ( codec_id ) ; int av_get_exact_bits_per_sample(enum AVCodecID codec_id) switch ( codec_id )  return 4 ; return 8 ; return 16 ; return 24 ; return 32 ; return 64 ; return 0 ; nb_samples = ( ( int64_t ) buf_size ) * 8 / ( av_get_bits_per_sample ( avctx -> codec_id ) * avctx -> channels ); int av_get_bits_per_sample(enum AVCodecID codec_id) switch ( codec_id )  return 2 ; return 3 ; return 4 ; return av_get_exact_bits_per_sample ( codec_id ) ; if ( nb_samples >= 2147483647 )  frame -> nb_samples = nb_samples; samples_size = av_samples_get_buffer_size ( ( ( void * ) 0 ) , avctx -> channels , frame -> nb_samples , avctx -> sample_fmt , 1 ); if ( ( ret = avcodec_fill_audio_frame ( frame , avctx -> channels , avctx -> sample_fmt , ( ( const uint8_t * ) samples ) , samples_size , 1 ) ) < 0 )  int avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align) int planar ; int needed_size ; needed_size = av_samples_get_buffer_size ( ( ( void * ) 0 ) , nb_channels , frame -> nb_samples , sample_fmt , align ); if ( buf_size < needed_size )  return - 22 ; planar = av_sample_fmt_is_planar ( sample_fmt ); if ( planar && nb_channels > 8 )  if ( ! ( frame -> extended_data = ( av_mallocz ( nb_channels * sizeof ( ( * frame -> extended_data ) ) ) ) ) )  return - '\f' ; frame -> extended_data = frame -> data; if ( ( ret = av_samples_fill_arrays ( frame -> extended_data , & frame -> linesize [ 0 ] , ( ( uint8_t * ) ( ( intptr_t ) buf ) ) , nb_channels , frame -> nb_samples , sample_fmt , align ) ) < 0 )  return ret ; return ret ; if ( avctx -> sample_rate && avctx -> time_base . num )  frame -> pts = ff_samples_to_time_base ( avctx , ( avctx -> internal -> sample_count ) ); frame -> pts = ( ( int64_t ) 0x8000000000000000UL ); avctx -> internal -> sample_count += frame -> nb_samples; frame = ( ( void * ) 0 ); got_packet = 0; ret = avcodec_encode_audio2 ( avctx , & pkt , frame , & got_packet ); int avcodec_encode_audio2(AVCodecContext *avctx,AVPacket *avpkt,const AVFrame *frame,int *got_packet_ptr) AVFrame tmp ; AVFrame * padded_frame = ( ( void * ) 0 ) ; int ret ; AVPacket user_pkt = * avpkt ; * got_packet_ptr = 0; if ( ! ( avctx -> codec -> capabilities & 0x20 ) && ! frame )  if ( frame && ! frame -> extended_data )  if ( av_sample_fmt_is_planar ( avctx -> sample_fmt ) && avctx -> channels > 8 )  tmp = * frame; tmp . extended_data = tmp . data; frame = ( & tmp ); if ( frame )  if ( avctx -> codec -> capabilities & 0x0040 )  if ( frame -> nb_samples > avctx -> frame_size )  if ( ! ( avctx -> codec -> capabilities & 0x10000 ) )  if ( frame -> nb_samples < avctx -> frame_size && ! avctx -> internal -> last_audio_frame )  ret = pad_last_frame ( avctx , & padded_frame , frame ); static int pad_last_frame(AVCodecContext *s,AVFrame **dst,const AVFrame *src) int ret ; if ( ! ( frame = avcodec_alloc_frame ( ) ) )  AVFrame *avcodec_alloc_frame() AVFrame * frame = ( av_malloc ( sizeof ( AVFrame ) ) ) ; if ( frame == ( ( void * ) 0 ) )  return ( ( void * ) 0 ) ; frame -> extended_data = ( ( void * ) 0 ); return frame ; return - '\f' ; * frame = * src; if ( ( ret = av_samples_get_buffer_size ( & frame -> linesize [ 0 ] , s -> channels , s -> frame_size , s -> sample_fmt , 0 ) ) < 0 )  if ( ! ( buf = ( av_malloc ( ret ) ) ) )  ret = - '\f'; frame -> nb_samples = s -> frame_size; if ( ( ret = avcodec_fill_audio_frame ( frame , s -> channels , s -> sample_fmt , buf , ret , 0 ) ) < 0 )  int avcodec_fill_audio_frame(AVFrame *frame,int nb_channels,enum AVSampleFormat sample_fmt,const uint8_t *buf,int buf_size,int align) int planar ; int needed_size ; needed_size = av_samples_get_buffer_size ( ( ( void * ) 0 ) , nb_channels , frame -> nb_samples , sample_fmt , align ); if ( buf_size < needed_size )  return - 22 ; planar = av_sample_fmt_is_planar ( sample_fmt ); if ( planar && nb_channels > 8 )  if ( ! ( frame -> extended_data = ( av_mallocz ( nb_channels * sizeof ( ( * frame -> extended_data ) ) ) ) ) )  return - '\f' ; frame -> extended_data = frame -> data; if ( ( ret = av_samples_fill_arrays ( frame -> extended_data , & frame -> linesize [ 0 ] , ( ( uint8_t * ) ( ( intptr_t ) buf ) ) , nb_channels , frame -> nb_samples , sample_fmt , align ) ) < 0 )  return ret ; return ret ; if ( ( ret = av_samples_copy ( frame -> extended_data , ( src -> extended_data ) , 0 , 0 , src -> nb_samples , s -> channels , s -> sample_fmt ) ) < 0 )  if ( ( ret = av_samples_set_silence ( frame -> extended_data , src -> nb_samples , frame -> nb_samples - src -> nb_samples , s -> channels , s -> sample_fmt ) ) < 0 )  return 0 ; return ret ; if ( ret < 0 )  frame = padded_frame; avctx -> internal -> last_audio_frame = 1; if ( frame -> nb_samples != avctx -> frame_size )  ret = ( ( avctx -> codec -> encode2 ) ( avctx , avpkt , frame , got_packet_ptr ) ); if ( ! ret )  if ( * got_packet_ptr )  if ( ! ( avctx -> codec -> capabilities & 0x20 ) )  if ( avpkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) )  avpkt -> pts = frame -> pts; if ( ! avpkt -> duration )  avpkt -> duration = ( ff_samples_to_time_base ( avctx , ( frame -> nb_samples ) ) ); avpkt -> dts = avpkt -> pts; avpkt -> size = 0; if ( avpkt -> data && avpkt -> data == avctx -> internal -> byte_buffer )  if ( user_pkt . data )  if ( user_pkt . size >= avpkt -> size )  memcpy ( user_pkt . data , ( avpkt -> data ) , ( avpkt -> size ) ); avpkt -> data = user_pkt . data; avpkt -> destruct = user_pkt . destruct; if ( needs_realloc && avpkt -> data )  uint8_t * new_data = ( av_realloc ( ( avpkt -> data ) , ( avpkt -> size + 16 ) ) ) ; if ( new_data )  avpkt -> data = new_data; av_free_packet ( avpkt ); av_init_packet ( avpkt ); avpkt -> flags |= 0x1; 