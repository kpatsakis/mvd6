svn_error_t *svn_stream_readline(svn_stream_t *stream,svn_stringbuf_t **stringbuf,const char *eol,svn_boolean_t *eof,apr_pool_t *pool) return stream_readline ( stringbuf , eof , eol , stream , pool ) ; static svn_error_t *stream_readline(svn_stringbuf_t **stringbuf,svn_boolean_t *eof,const char *eol,svn_stream_t *stream,apr_pool_t *pool) * eof = 0; if ( svn_stream_supports_mark ( stream ) && svn_stream__is_buffered ( stream ) )  svn_boolean_t svn_stream__is_buffered(svn_stream_t *stream) if ( stream -> is_buffered_fn == ( ( void * ) 0 ) )  return 0 ; return ( stream -> is_buffered_fn ) ( stream -> baton ) ; svn_boolean_t svn_stream_supports_mark(svn_stream_t *stream) return stream -> mark_fn != ( ( void * ) 0 ) ; svn_error_t * svn_err__temp = stream_readline_chunky ( stringbuf , eof , eol , stream , pool ) ; if ( svn_err__temp )  while ( 0 )  static svn_error_t *stream_readline_chunky(svn_stringbuf_t **stringbuf,svn_boolean_t *eof,const char *eol,svn_stream_t *stream,apr_pool_t *pool) const size_t eol_len = strlen ( eol ) ; total_parsed = ( eol_pos - buffer ) + eol_len; eol_pos = ( strstr ( ( str -> data + str -> len - numbytes - ( eol_len - 1 ) ) , eol ) ); if ( numbytes < 80 && eol_pos == ( ( void * ) 0 ) )  while ( eol_pos == ( ( void * ) 0 ) )  total_parsed = ( eol_pos - ( str -> data ) ) + eol_len; str -> len = ( eol_pos - ( str -> data ) ); str -> data [ str -> len ] = 0; return svn_stream_skip ( stream , total_parsed ) ; svn_error_t *svn_stream_skip(svn_stream_t *stream,apr_size_t len) if ( stream -> skip_fn == ( ( void * ) 0 ) )  return skip_default_handler ( stream -> baton , len , stream -> read_fn ) ; static svn_error_t *skip_default_handler(void *baton,apr_size_t len,svn_read_fn_t read_fn) apr_size_t to_read = len ; while ( to_read > 0 && bytes_read > 0 )  bytes_read = ( sizeof ( buffer ) < to_read ? sizeof ( buffer ) : to_read ); svn_error_t * svn_err__temp = read_fn ( baton , buffer , & bytes_read ) ; if ( svn_err__temp )  return svn_err__temp ; to_read -= bytes_read; return ( stream -> skip_fn ) ( stream -> baton , len ) ; 