char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref) state_num s ; state_num s1 ; const unsigned char * p ; state_num * * trans ; state_num * t ; unsigned char eol = eolbyte ; s = s1 = 0; p = ( ( const unsigned char * ) begin ); trans = d -> trans; * end = eol; if ( d -> mb_cur_max > 1 )  while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  if ( p > buf_end )  s1 = s; if ( s == 0 )  if ( ( ( char * ) p ) >= end )  if ( d -> states [ s ] . mbps . nelem == 0 )  s = t [ * ( p ++ ) ]; if ( backref )  s = transit_state ( d , s , & p ); trans = d -> trans; while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )  s1 = t [ * ( p ++ ) ]; if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )  state_num tmp = s ; s = s1; s1 = tmp; s = t [ * ( p ++ ) ]; if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )  if ( d -> success [ s ] & sbit [ * p ] )  s1 = s; if ( d -> mb_cur_max > 1 )  s = transit_state ( d , s , & p ); trans = d -> trans; s = d -> fails [ s ] [ * ( p ++ ) ]; if ( ( ( char * ) p ) > end )  if ( s >= 0 )  trans = d -> trans; if ( p [ - 1 ] == eol && allow_nl )  s = d -> newlines [ s1 ]; s = 0; static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp) state_num s1 ; int mbclen ; int maxlen = 0 ; size_t i ; size_t nelem = d -> states [ s ] . mbps . nelem ; position_set follows ; const unsigned char * p1 = * pp ; wchar_t wc ; if ( nelem > 0 )  match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ); for (i = 0; i < nelem; i++) if ( match_lens [ i ] > maxlen )  maxlen = match_lens [ i ]; if ( nelem == 0 || maxlen == 0 )  wc = inputwcs [ * pp - mbclen - buf_begin ]; s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); while ( * pp - p1 < maxlen )  transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows ); wc = inputwcs [ * pp - mbclen - buf_begin ]; s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) ); static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps) state_num s1 ; s1 = s; copy ( ( & d -> states [ s1 ] . elems ) , pps ); static void copy(const position_set *src,position_set *dst) if ( dst -> alloc <= src -> nelem )  size_t new_n_alloc = src -> nelem + ( ! dst -> elems ) ; dst -> elems = ( x2nrealloc ( ( dst -> elems ) , & new_n_alloc , sizeof ( ( * dst -> elems ) ) ) ); dst -> alloc = new_n_alloc; while ( 0 )  memcpy ( ( dst -> elems ) , ( src -> elems ) , sizeof ( dst -> elems [ 0 ] ) * src -> nelem ); dst -> nelem = src -> nelem; 