int key_link(struct key *keyring, struct key *key) int ret ; if ( test_bit ( KEY_FLAG_TRUSTED_ONLY , & keyring -> flags ) && ! test_bit ( KEY_FLAG_TRUSTED , & key -> flags ) )  ret = __key_link_begin ( keyring , & key -> index_key , & edit ); if ( ret == 0 )  ret = __key_link_check_live_key ( keyring , key ); int __key_link_check_live_key(struct key *keyring, struct key *key) if ( key -> type == & key_type_keyring )  return keyring_detect_cycle ( keyring , key ) ; static int keyring_detect_cycle(struct key *A, struct key *B) struct keyring_search_context ctx . index_key = A -> index_key . match_data . raw_data = A . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT . iterator = keyring_detect_cycle_iterator . flags = ( KEYRING_SEARCH_NO_STATE_CHECK KEYRING_SEARCH_NO_UPDATE_TIME KEYRING_SEARCH_NO_CHECK_PERM KEYRING_SEARCH_DETECT_TOO_DEEP ) , search_nested_keyrings ( B , & ctx ); static bool search_nested_keyrings(struct key struct keyring_search_context *ctx) if ( ctx -> index_key . description )  ctx -> index_key . desc_len = strlen ( ctx -> index_key . description ); if ( ctx -> match_data . lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE || keyring_compare_object ( keyring , & ctx -> index_key ) )  ctx -> skipped_ret = 2; switch ( ctx -> iterator ( keyring_key_to_ptr ( keyring ) , ctx ) )  key = key_ref_to_ptr ( ctx -> result ); key_check ( key ); if ( ! ( ctx -> flags & KEYRING_SEARCH_NO_UPDATE_TIME ) )  key -> last_used_at = ctx -> now . tv_sec; keyring -> last_used_at = ctx -> now . tv_sec; stack [ -- sp ] . keyring -> last_used_at = ctx -> now . tv_sec; 