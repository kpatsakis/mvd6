enum AVPixelFormat ff_thread_get_format(AVCodecContext *avctx, const enum AVPixelFormat *fmt) return ff_get_format ( avctx , fmt ) ; int ff_get_format(AVCodecContext *avctx, const enum AVPixelFormat *fmt) enum AVPixelFormat * choices ; unsigned n = 0 ; choices = av_malloc_array ( n + 1 , sizeof ( * choices ) ); if ( ! choices )  memcpy ( choices , fmt , ( n + 1 ) * sizeof ( * choices ) ); ret = avctx -> get_format ( avctx , choices ); desc = av_pix_fmt_desc_get ( ret ); if ( ! desc )  if ( ! ( desc -> flags & AV_PIX_FMT_FLAG_HWACCEL ) )  if ( ! setup_hwaccel ( avctx , ret , desc -> name ) )  static int setup_hwaccel(AVCodecContext const enum AVPixelFormat const char *name) AVHWAccel * hwa = find_hwaccel ( avctx -> codec_id , fmt ) ; static AVHWAccel *find_hwaccel(enum AVCodecID enum AVPixelFormat pix_fmt) if ( hwaccel -> id == codec_id && hwaccel -> pix_fmt == pix_fmt )  if ( ! hwa )  av_log ( avctx , AV_LOG_ERROR , "Could not find an AVHWAccel for the pixel format: %s" , name ); if ( hwa -> capabilities & HWACCEL_CODEC_CAP_EXPERIMENTAL && avctx -> strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL )  av_log ( avctx , AV_LOG_WARNING , "Ignoring experimental hwaccel: %s\n" , hwa -> name ); if ( hwa -> priv_data_size )  avctx -> internal -> hwaccel_priv_data = av_mallocz ( hwa -> priv_data_size ); if ( ! avctx -> internal -> hwaccel_priv_data )  if ( hwa -> init )  ret = hwa -> init ( avctx ); if ( ret < 0 )  av_freep ( & avctx -> internal -> hwaccel_priv_data ); return ret ; avctx -> hwaccel = hwa; for (n = 0; choices[n] != ret; n++) av_assert0 ( choices [ n ] != AV_PIX_FMT_NONE ); choices [ n ] = choices [ n + 1 ]; while ( choices [ n ++ ] != AV_PIX_FMT_NONE )  av_freep ( & choices ); return ret ; 