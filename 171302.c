 nestegg_read_packet(nestegg * ctx, nestegg_packet ** pkt) uint64_t id , size ; r = ne_peek_element ( ctx , & id , & size ); static ne_peek_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; if ( ctx -> last_valid )  return 1 ; r = ne_read_id ( ctx -> io , & ctx -> last_id , NULL ); static ne_read_id(nestegg_io * io, uint64_t * value, uint64_t * length) return ne_bare_read_vint ( io , value , length , MASK_NONE ) ; static ne_bare_read_vint(nestegg_io * io, uint64_t * value, uint64_t * length, enum vint_mask maskflag) int r ; unsigned char b ; size_t maxlen = 8 ; unsigned int count = 1 , mask = 1 << 7 ; r = ne_io_read ( io , & b , 1 ); static ne_io_read(nestegg_io * io, void * buffer, size_t length) return io -> read ( buffer , length , io -> userdata ) ; if ( r != 1 )  return r ; while ( count < maxlen )  if ( ( b & mask ) != 0 )  mask >>= 1; count += 1; while ( -- count )  r = ne_io_read ( io , & b , 1 ); static ne_io_read(nestegg_io * io, void * buffer, size_t length) return io -> read ( buffer , length , io -> userdata ) ; if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  return r ; r = ne_read_vint ( ctx -> io , & ctx -> last_size , NULL ); static ne_read_vint(nestegg_io * io, uint64_t * value, uint64_t * length) return ne_bare_read_vint ( io , value , length , MASK_FIRST_BIT ) ; static ne_bare_read_vint(nestegg_io * io, uint64_t * value, uint64_t * length, enum vint_mask maskflag) int r ; unsigned char b ; size_t maxlen = 8 ; unsigned int count = 1 , mask = 1 << 7 ; r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; while ( count < maxlen )  if ( ( b & mask ) != 0 )  mask >>= 1; count += 1; while ( -- count )  r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  if ( ne_is_suspend_element ( id ) )  static ne_is_suspend_element(uint64_t id) if ( id == ID_SIMPLE_BLOCK || id == ID_BLOCK )  return 1 ; return 0 ; r = ne_parse ( ctx , NULL , - 1 ); if ( r != 1 )  static ne_parse(nestegg * ctx, struct ebml_element_desc * top_level, int64_t max_offset) int r ; int64_t * data_offset ; uint64_t id , size , peeked_id ; struct ebml_element_desc * element ; if ( ! ctx -> ancestor )  if ( max_offset > 0 && ne_io_tell ( ctx -> io ) >= max_offset )  static ne_io_tell(nestegg_io * io) return io -> tell ( io -> userdata ) ; r = ne_peek_element ( ctx , & id , & size ); static ne_peek_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; if ( ctx -> last_valid )  return 1 ; r = ne_read_id ( ctx -> io , & ctx -> last_id , NULL ); if ( r != 1 )  return r ; r = ne_read_vint ( ctx -> io , & ctx -> last_size , NULL ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  peeked_id = id; element = ne_find_element ( id , ctx -> ancestor -> node ); static struct ebml_element_desc ne_find_element(uint64_t id, struct ebml_element_desc * elements) struct ebml_element_desc * element ; for (element = elements; element->id; ++element) if ( element -> id == id )  return element ; return NULL ; if ( element )  if ( element -> flags & DESC_FLAG_SUSPEND )  r = ne_read_element ( ctx , & id , & size ); static ne_read_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; r = ne_peek_element ( ctx , id , size ); static ne_peek_element(nestegg * ctx, uint64_t * id, uint64_t * size) int r ; if ( ctx -> last_valid )  return 1 ; r = ne_read_id ( ctx -> io , & ctx -> last_id , NULL ); if ( r != 1 )  return r ; r = ne_read_vint ( ctx -> io , & ctx -> last_size , NULL ); if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  return r ; return 1 ; if ( r != 1 )  assert ( id == peeked_id ); if ( element -> flags & DESC_FLAG_OFFSET )  data_offset = ( int64_t * ) ( ctx -> ancestor -> data + element -> data_offset ); * data_offset = ne_io_tell ( ctx -> io ); static ne_io_tell(nestegg_io * io) return io -> tell ( io -> userdata ) ; if ( * data_offset < 0 )  if ( element -> type == TYPE_MASTER )  if ( element -> flags & DESC_FLAG_MULTI )  if ( ne_read_master ( ctx , element ) < 0 )  static ne_read_master(nestegg * ctx, struct ebml_element_desc * desc) assert ( desc -> type == TYPE_MASTER && desc -> flags & DESC_FLAG_MULTI ); ctx -> log ( ctx , NESTEGG_LOG_DEBUG , "multi master element %llx (%s)" , desc -> id , desc -> name ); list = ( struct ebml_list * ) ( ctx -> ancestor -> data + desc -> offset ); node = ne_pool_alloc ( sizeof ( * node ) , ctx -> alloc_pool ); static void ne_pool_alloc(size_t size, struct pool_ctx * pool) p = h_malloc ( size ); if ( ! p )  hattach ( p , pool ); memset ( p , 0 , size ); return p ; if ( ! node )  node -> id = desc -> id; node -> data = ne_pool_alloc ( desc -> size , ctx -> alloc_pool ); static void ne_pool_alloc(size_t size, struct pool_ctx * pool) p = h_malloc ( size ); if ( ! p )  hattach ( p , pool ); memset ( p , 0 , size ); return p ; if ( ! node -> data )  oldtail = list -> tail; if ( oldtail )  oldtail -> next = node; list -> tail = node; if ( ! list -> head )  list -> head = node; ctx -> log ( ctx , NESTEGG_LOG_DEBUG , " -> using data %p" , node -> data ); if ( ne_ctx_push ( ctx , desc -> children , node -> data ) < 0 )  static ne_ctx_push(nestegg * ctx, struct ebml_element_desc * ancestor, void * data) item -> previous = ctx -> ancestor; item -> node = ancestor; item -> data = data; ctx -> ancestor = item; if ( ne_read_single_master ( ctx , element ) < 0 )  static ne_read_single_master(nestegg * ctx, struct ebml_element_desc * desc) assert ( desc -> type == TYPE_MASTER && ! ( desc -> flags & DESC_FLAG_MULTI ) ); ctx -> log ( ctx , NESTEGG_LOG_DEBUG , "single master element %llx (%s)" , desc -> id , desc -> name ); ctx -> log ( ctx , NESTEGG_LOG_DEBUG , " -> using data %p (%u)" , ctx -> ancestor -> data + desc -> offset , desc -> offset ); return ne_ctx_push ( ctx , desc -> children , ctx -> ancestor -> data + desc -> offset ) ; static ne_ctx_push(nestegg * ctx, struct ebml_element_desc * ancestor, void * data) item -> previous = ctx -> ancestor; item -> node = ancestor; item -> data = data; ctx -> ancestor = item; r = ne_read_simple ( ctx , element , size ); static ne_read_simple(nestegg * ctx, struct ebml_element_desc * desc, size_t length) storage = ( struct ebml_type * ) ( ctx -> ancestor -> data + desc -> offset ); if ( storage -> read )  ctx -> log ( ctx , NESTEGG_LOG_DEBUG , "element %llx (%s) already read, skipping" , desc -> id , desc -> name ); storage -> type = desc -> type; ctx -> log ( ctx , NESTEGG_LOG_DEBUG , "element %llx (%s) -> %p (%u)" , desc -> id , desc -> name , storage , desc -> offset ); switch ( desc -> type )  r = ne_read_uint ( ctx -> io , & storage -> v . u , length ); static ne_read_uint(nestegg_io * io, uint64_t * val, uint64_t length) if ( length == 0 || length > 8 )  r = ne_io_read ( io , & b , 1 ); static ne_io_read(nestegg_io * io, void * buffer, size_t length) return io -> read ( buffer , length , io -> userdata ) ; if ( r != 1 )  return r ; * val = b; while ( -- length )  r = ne_io_read ( io , & b , 1 ); static ne_io_read(nestegg_io * io, void * buffer, size_t length) return io -> read ( buffer , length , io -> userdata ) ; if ( r != 1 )  return r ; * val <<= 8; * val |= b; r = ne_read_float ( ctx -> io , & storage -> v . f , length ); static ne_read_float(nestegg_io * io, double * val, uint64_t length) if ( length != 4 && length != 8 )  r = ne_read_uint ( io , & value . u , length ); static ne_read_uint(nestegg_io * io, uint64_t * val, uint64_t length) if ( length == 0 || length > 8 )  r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; * val = b; while ( -- length )  r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; * val <<= 8; * val |= b; if ( r != 1 )  return r ; if ( length == 4 )  * val = value . f; * val = value . d; r = ne_read_int ( ctx -> io , & storage -> v . i , length ); static ne_read_int(nestegg_io * io, int64_t * val, uint64_t length) r = ne_read_uint ( io , & uval , length ); static ne_read_uint(nestegg_io * io, uint64_t * val, uint64_t length) if ( length == 0 || length > 8 )  r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; * val = b; while ( -- length )  r = ne_io_read ( io , & b , 1 ); if ( r != 1 )  return r ; * val <<= 8; * val |= b; if ( r != 1 )  return r ; if ( length < sizeof ( int64_t ) )  base <<= length * 8 - 1; if ( uval >= base )  base <<= length * 8; * val = uval - base; * val = ( int64_t ) uval; r = ne_read_string ( ctx , & storage -> v . s , length ); static ne_read_string(nestegg * ctx, char ** val, uint64_t length) if ( length > LIMIT_STRING )  str = ne_pool_alloc ( length + 1 , ctx -> alloc_pool ); static void ne_pool_alloc(size_t size, struct pool_ctx * pool) p = h_malloc ( size ); if ( ! p )  hattach ( p , pool ); memset ( p , 0 , size ); return p ; if ( ! str )  if ( length )  r = ne_io_read ( ctx -> io , ( unsigned char * ) str , length ); static ne_io_read(nestegg_io * io, void * buffer, size_t length) return io -> read ( buffer , length , io -> userdata ) ; if ( r != 1 )  return r ; str [ length ] = '\0'; * val = str; r = ne_read_binary ( ctx , & storage -> v . b , length ); static ne_read_binary(nestegg * ctx, struct ebml_binary * val, uint64_t length) if ( length == 0 || length > LIMIT_BINARY )  val -> data = ne_pool_alloc ( length , ctx -> alloc_pool ); static void ne_pool_alloc(size_t size, struct pool_ctx * pool) p = h_malloc ( size ); if ( ! p )  hattach ( p , pool ); memset ( p , 0 , size ); return p ; if ( ! val -> data )  val -> length = length; return ne_io_read ( ctx -> io , val -> data , length ) ; static ne_io_read(nestegg_io * io, void * buffer, size_t length) return io -> read ( buffer , length , io -> userdata ) ; if ( r == 1 )  storage -> read = 1; return r ; if ( r < 0 )  if ( ne_is_ancestor_element ( id , ctx -> ancestor -> previous ) )  static ne_is_ancestor_element(uint64_t id, struct list_node * ancestor) for (; ancestor; ancestor = ancestor->previous) for (element = ancestor->node; element->id; ++element) if ( element -> id == id )  if ( top_level && ctx -> ancestor -> node == top_level )  r = ne_read_element ( ctx , & id , & size ); static ne_read_element(nestegg * ctx, uint64_t * id, uint64_t * size) r = ne_peek_element ( ctx , id , size ); if ( r != 1 )  return r ; ctx -> last_valid = 0; if ( r != 1 )  r = ne_io_read_skip ( ctx -> io , size ); static ne_io_read_skip(nestegg_io * io, size_t length) while ( length > 0 )  get = length < sizeof ( buf ) ? length : sizeof ( buf ); r = ne_io_read ( io , buf , get ); static ne_io_read(nestegg_io * io, void * buffer, size_t length) return io -> read ( buffer , length , io -> userdata ) ; if ( r != 1 )  length -= get; return r ; if ( r != 1 )  