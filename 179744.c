static int transcode_step() OutputStream * ost ; InputStream * ist ; int ret ; ost = choose_output ( ); static OutputStream *choose_output() int i ; int64_t opts_min = 9223372036854775807L ; OutputStream * ost_min = ( ( void * ) 0 ) ; for (i = 0; i < nb_output_streams; i++) OutputStream * ost = output_streams [ i ] ; int64_t opts = av_rescale_q ( ost -> st -> cur_dts , ost -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) if ( ! ost -> unavailable && ! ost -> finished && opts < opts_min )  opts_min = opts; ost_min = ost; return ost_min ; if ( ! ost )  if ( ost -> filter )  if ( ( ret = transcode_from_filter ( ost -> filter -> graph , & ist ) ) < 0 )  static int transcode_from_filter(FilterGraph *graph,InputStream **best_ist) int ret ; ret = avfilter_graph_request_oldest ( graph -> graph ); if ( ret >= 0 )  return reap_filters ( ) ; static int reap_filters() int i ; for (i = 0; i < nb_output_streams; i++) OutputStream * ost = output_streams [ i ] ; if ( ! ost -> filter )  if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  return - 12 ; return 0 ; if ( ret == - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) )  ret = reap_filters ( ); static int reap_filters() int i ; OutputStream * ost = output_streams [ i ] ; if ( ! ost -> filter )  if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )  return - 12 ; return 0 ; return ret ; if ( ret != - 11 )  return ret ; return 0 ; if ( ! ist )  ist = input_streams [ ost -> source_index ]; ret = process_input ( ist -> file_index ); static int process_input(int file_index) InputFile * ifile = input_files [ file_index ] ; AVFormatContext * is ; InputStream * ist ; AVPacket pkt ; int ret ; int i ; is = ifile -> ctx; ret = get_input_packet ( ifile , & pkt ); static int get_input_packet(InputFile *f,AVPacket *pkt) if ( nb_input_files > 1 )  return get_input_packet_mt ( f , pkt ) ; static int get_input_packet_mt(InputFile *f,AVPacket *pkt) int ret = 0 ; if ( av_fifo_size ( f -> fifo ) )  if ( f -> finished )  ret = - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ); ret = - 11; return ret ; return av_read_frame ( f -> ctx , pkt ) ; if ( ret == - 11 )  if ( ret < 0 )  ifile -> eof_reached = 1; for (i = 0; i < ifile -> nb_streams; i++) ist = input_streams [ ifile -> ist_index + i ]; if ( pkt . stream_index >= ifile -> nb_streams )  ist = input_streams [ ifile -> ist_index + pkt . stream_index ]; if ( ist -> discard )  if ( ! ist -> wrap_correction_done && is -> start_time != ( ( int64_t ) 0x8000000000000000UL ) && ist -> st -> pts_wrap_bits < 64 )  ist -> wrap_correction_done = 1; ist -> wrap_correction_done = 0; ist -> wrap_correction_done = 0; if ( pkt . pts != ( ( int64_t ) 0x8000000000000000UL ) )  pkt . pts *= ist -> ts_scale; if ( pkt . dts != ( ( int64_t ) 0x8000000000000000UL ) )  pkt . dts *= ist -> ts_scale; if ( pkt . dts != ( ( int64_t ) 0x8000000000000000UL ) && ist -> next_dts != ( ( int64_t ) 0x8000000000000000UL ) && ! copy_ts )  if ( is -> iformat -> flags & 0x0200 )  pkt . dts = ( ( int64_t ) 0x8000000000000000UL ); if ( pkt . pts != ( ( int64_t ) 0x8000000000000000UL ) )  pkt . pts = ( ( int64_t ) 0x8000000000000000UL ); sub2video_heartbeat ( ist , pkt . pts ); static void sub2video_heartbeat(InputStream *ist,int64_t pts) InputFile * infile = input_files [ ist -> file_index ] ; int i ; int64_t pts2 ; for (i = 0; i < infile -> nb_streams; i++) InputStream * ist2 = input_streams [ infile -> ist_index + i ] ; if ( ! ist2 -> sub2video . ref )  pts2 = av_rescale_q ( pts , ist -> st -> time_base , ist2 -> st -> time_base ) - 1; if ( pts2 <= ist2 -> sub2video . last_pts )  if ( pts2 >= ist2 -> sub2video . end_pts )  sub2video_update ( ist2 , ( ( void * ) 0 ) ); static void sub2video_update(InputStream *ist,AVSubtitle *sub) int h = ist -> sub2video . h ; AVFilterBufferRef * ref = ist -> sub2video . ref ; int8_t * dst ; int dst_linesize ; if ( ! ref )  dst = ref -> data [ 0 ]; dst_linesize = ref -> linesize [ 0 ]; memset ( dst , 0 , ( h * dst_linesize ) ); sub2video_copy_rect ( dst , dst_linesize , w , h , sub -> rects [ i ] ); static void sub2video_copy_rect(uint8_t *dst,int dst_linesize,int w,int h,AVSubtitleRect *r) if ( ( r -> type ) != SUBTITLE_BITMAP )  if ( r -> x < 0 || r -> x + r -> w > w || r -> y < 0 || r -> y + r -> h > h )  dst += r -> y * dst_linesize + r -> x * 4; src = r -> pict . data [ 0 ]; pal = ( ( uint32_t * ) r -> pict . data [ 1 ] ); for (y = 0; y < r -> h; y++) dst2 = ( ( uint32_t * ) dst ); src2 = src; for (x = 0; x < r -> w; x++) * ( dst2 ++ ) = pal [ * ( src2 ++ ) ]; dst += dst_linesize; src += r -> pict . linesize [ 0 ]; 