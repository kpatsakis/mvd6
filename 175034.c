svn_error_t *svn_stream_readline(svn_stream_t *stream,svn_stringbuf_t **stringbuf,const char *eol,svn_boolean_t *eof,apr_pool_t *pool) return stream_readline ( stringbuf , eof , eol , stream , pool ) ; static svn_error_t *stream_readline(svn_stringbuf_t **stringbuf,svn_boolean_t *eof,const char *eol,svn_stream_t *stream,apr_pool_t *pool) * eof = 0; if ( svn_stream_supports_mark ( stream ) && svn_stream__is_buffered ( stream ) )  svn_boolean_t svn_stream__is_buffered(svn_stream_t *stream) if ( stream -> is_buffered_fn == ( ( void * ) 0 ) )  return 0 ; return ( stream -> is_buffered_fn ) ( stream -> baton ) ; svn_boolean_t svn_stream_supports_mark(svn_stream_t *stream) return stream -> mark_fn != ( ( void * ) 0 ) ; svn_error_t * svn_err__temp = stream_readline_chunky ( stringbuf , eof , eol , stream , pool ) ; if ( svn_err__temp )  while ( 0 )  static svn_error_t *stream_readline_chunky(svn_stringbuf_t **stringbuf,svn_boolean_t *eof,const char *eol,svn_stream_t *stream,apr_pool_t *pool) char buffer [ 80 + 1 ] ; apr_size_t numbytes ; const char * eol_pos ; const size_t eol_len = strlen ( eol ) ; svn_error_t * svn_err__temp = svn_stream_mark ( stream , & mark , pool ) ; svn_error_t *svn_stream_mark(svn_stream_t *stream,svn_stream_mark_t **mark,apr_pool_t *pool) if ( stream -> mark_fn == ( ( void * ) 0 ) )  return svn_error_create ( SVN_ERR_STREAM_SEEK_NOT_SUPPORTED , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ; return ( stream -> mark_fn ) ( stream -> baton , mark , pool ) ; if ( svn_err__temp )  while ( 0 )  numbytes = 80; svn_error_t * svn_err__temp = svn_stream_read ( stream , buffer , & numbytes ) ; svn_error_t *svn_stream_read(svn_stream_t *stream,char *buffer,apr_size_t *len) if ( ! ( stream -> read_fn != ( ( void * ) 0 ) ) )  svn_error_t * svn_err__temp = svn_error__malfunction ( ! 0 , "stream.c" , 143 , "stream->read_fn != NULL" ) ; if ( svn_err__temp )  return svn_err__temp ; while ( 0 )  while ( 0 )  return ( stream -> read_fn ) ( stream -> baton , buffer , len ) ; if ( svn_err__temp )  while ( 0 )  buffer [ numbytes ] = '\0'; eol_pos = ( strstr ( buffer , eol ) ); if ( eol_pos != ( ( void * ) 0 ) )  if ( numbytes < 80 )  svn_stringbuf_t * str ; str = svn_stringbuf_create_ensure ( ( 2 * 80 ) , pool ); numbytes = 80; svn_error_t * svn_err__temp = svn_stream_read ( stream , str -> data + str -> len , & numbytes ) ; svn_error_t *svn_stream_read(svn_stream_t *stream,char *buffer,apr_size_t *len) if ( ! ( stream -> read_fn != ( ( void * ) 0 ) ) )  svn_error_t * svn_err__temp = svn_error__malfunction ( ! 0 , "stream.c" , 143 , "stream->read_fn != NULL" ) ; if ( svn_err__temp )  return svn_err__temp ; while ( 0 )  while ( 0 )  return ( stream -> read_fn ) ( stream -> baton , buffer , len ) ; if ( svn_err__temp )  while ( 0 )  str -> len += numbytes; str -> data [ str -> len ] = '\0'; eol_pos = ( strstr ( ( str -> data + str -> len - numbytes - ( eol_len - 1 ) ) , eol ) ); if ( numbytes < 80 && eol_pos == ( ( void * ) 0 ) )  while ( eol_pos == ( ( void * ) 0 ) )  total_parsed = ( eol_pos - ( str -> data ) ) + eol_len; str -> len = ( eol_pos - ( str -> data ) ); str -> data [ str -> len ] = 0; return svn_stream_skip ( stream , total_parsed ) ; svn_error_t *svn_stream_skip(svn_stream_t *stream,apr_size_t len) if ( stream -> skip_fn == ( ( void * ) 0 ) )  return skip_default_handler ( stream -> baton , len , stream -> read_fn ) ; static svn_error_t *skip_default_handler(void *baton,apr_size_t len,svn_read_fn_t read_fn) apr_size_t to_read = len ; while ( to_read > 0 && bytes_read > 0 )  bytes_read = ( sizeof ( buffer ) < to_read ? sizeof ( buffer ) : to_read ); svn_error_t * svn_err__temp = read_fn ( baton , buffer , & bytes_read ) ; if ( svn_err__temp )  return svn_err__temp ; to_read -= bytes_read; return ( stream -> skip_fn ) ( stream -> baton , len ) ; 