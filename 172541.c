static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom) int entries ; entries = avio_rb32 ( pb ); return ff_mov_read_stsd_entries ( c , pb , entries ) ; int ff_mov_read_stsd_entries(MOVContext *c, AVIOContext *pb, int entries) AVStream * st ; MOVStreamContext * sc ; int j , pseudo_stream_id ; if ( c -> fc -> nb_streams < 1 )  st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ]; sc = st -> priv_data; for (pseudo_stream_id=0; pseudo_stream_id<entries; pseudo_stream_id++) enum CodecID id ; int dref_id = 1 ; MOVAtom a = { AV_RL32 ( "stsd" ) } ; int64_t start_pos = avio_tell ( pb ) ; int size = avio_rb32 ( pb ) ; uint32_t format = avio_rl32 ( pb ) ; if ( size >= 16 )  dref_id = avio_rb16 ( pb ); if ( size <= 0 )  if ( st -> codec -> codec_tag && st -> codec -> codec_tag != format && ( c -> fc -> video_codec_id ? ff_codec_get_id ( ff_codec_movvideo_tags , format ) != c -> fc -> video_codec_id : st -> codec -> codec_tag != MKTAG ( 'j' , 'p' , 'e' , 'g' ) ) )  sc -> pseudo_stream_id = st -> codec -> codec_tag ? - 1 : pseudo_stream_id; sc -> dref_id = dref_id; st -> codec -> codec_tag = format; id = ff_codec_get_id ( ff_codec_movaudio_tags , format ); if ( id <= 0 && ( ( format & 0xFFFF ) == 'm' + ( 's' << 8 ) || ( format & 0xFFFF ) == 'T' + ( 'S' << 8 ) ) )  id = ff_codec_get_id ( ff_codec_wav_tags , av_bswap32 ( format ) & 0xFFFF ); if ( st -> codec -> codec_type != AVMEDIA_TYPE_VIDEO && id > 0 )  st -> codec -> codec_type = AVMEDIA_TYPE_AUDIO; if ( st -> codec -> codec_type != AVMEDIA_TYPE_AUDIO && format && format != MKTAG ( 'm' , 'p' , '4' , 's' ) )  id = ff_codec_get_id ( ff_codec_movvideo_tags , format ); if ( id <= 0 )  id = ff_codec_get_id ( ff_codec_bmp_tags , format ); if ( id > 0 )  st -> codec -> codec_type = AVMEDIA_TYPE_VIDEO; if ( st -> codec -> codec_type == AVMEDIA_TYPE_DATA || ( st -> codec -> codec_type == AVMEDIA_TYPE_SUBTITLE && st -> codec -> codec_id == CODEC_ID_NONE ) )  id = ff_codec_get_id ( ff_codec_movsubtitle_tags , format ); if ( id > 0 )  st -> codec -> codec_type = AVMEDIA_TYPE_SUBTITLE; if ( st -> codec -> codec_type == AVMEDIA_TYPE_VIDEO )  unsigned int color_depth , len ; int color_greyscale ; int color_table_id ; st -> codec -> codec_id = id; st -> codec -> width = avio_rb16 ( pb ); st -> codec -> height = avio_rb16 ( pb ); if ( ! memcmp ( st -> codec -> codec_name , "Planar Y'CbCr 8-bit 4:2:0" , 25 ) )  st -> codec -> codec_tag = MKTAG ( 'I' , '4' , '2' , '0' ); st -> codec -> bits_per_coded_sample = avio_rb16 ( pb ); color_table_id = avio_rb16 ( pb ); color_depth = st -> codec -> bits_per_coded_sample & 0x1F; color_greyscale = st -> codec -> bits_per_coded_sample & 0x20; if ( ( color_depth == 2 ) || ( color_depth == 4 ) || ( color_depth == 8 ) )  unsigned int color_start , color_count , color_end ; unsigned char a , r , g , b ; if ( color_greyscale )  st -> codec -> bits_per_coded_sample = color_depth; if ( color_table_id )  color_start = avio_rb32 ( pb ); color_end = avio_rb16 ( pb ); if ( ( color_start <= 255 ) && ( color_end <= 255 ) )  for (j = color_start; j <= color_end; j++) a = avio_r8 ( pb ); if ( st -> codec -> codec_type == AVMEDIA_TYPE_AUDIO )  int bits_per_sample , flags ; uint16_t version = avio_rb16 ( pb ) ; st -> codec -> codec_id = id; st -> codec -> channels = avio_rb16 ( pb ); st -> codec -> bits_per_coded_sample = avio_rb16 ( pb ); st -> codec -> sample_rate = ( ( avio_rb32 ( pb ) >> 16 ) ); if ( ! c -> isom )  if ( version == 1 )  if ( version == 2 )  st -> codec -> sample_rate = av_int2double ( avio_rb64 ( pb ) ); st -> codec -> channels = avio_rb32 ( pb ); st -> codec -> bits_per_coded_sample = avio_rb32 ( pb ); flags = avio_rb32 ( pb ); if ( format == MKTAG ( 'l' , 'p' , 'c' , 'm' ) )  st -> codec -> codec_id = ff_mov_get_lpcm_codec_id ( st -> codec -> bits_per_coded_sample , flags ); enum CodecID ff_mov_get_lpcm_codec_id(int bps, int flags) if ( flags & 1 )  if ( flags & 2 )  if ( bps == 32 )  if ( bps == 64 )  if ( bps == 32 )  if ( bps == 64 )  if ( flags & 2 )  if ( bps == 8 )  if ( flags & 4 )  if ( bps == 16 )  if ( bps == 24 )  if ( bps == 32 )  if ( bps == 8 )  if ( flags & 4 )  if ( bps == 16 )  if ( bps == 24 )  if ( bps == 32 )  switch ( st -> codec -> codec_id )  if ( st -> codec -> bits_per_coded_sample == 16 )  st -> codec -> codec_id = CODEC_ID_PCM_S16BE; if ( st -> codec -> bits_per_coded_sample == 8 )  st -> codec -> codec_id = CODEC_ID_PCM_S8; if ( st -> codec -> bits_per_coded_sample == 24 )  st -> codec -> codec_id = st -> codec -> codec_id == CODEC_ID_PCM_S16BE ? CODEC_ID_PCM_S24BE : CODEC_ID_PCM_S24LE; bits_per_sample = av_get_bits_per_sample ( st -> codec -> codec_id ); if ( bits_per_sample )  st -> codec -> bits_per_coded_sample = bits_per_sample; if ( st -> codec -> codec_type == AVMEDIA_TYPE_SUBTITLE )  st -> codec -> codec_id = id; st -> codec -> width = sc -> width; st -> codec -> height = sc -> height; if ( st -> codec -> codec_tag == MKTAG ( 't' , 'm' , 'c' , 'd' ) )  int val ; val = avio_rb32 ( pb ); if ( val & 1 )  st -> codec -> flags2 |= CODEC_FLAG2_DROP_FRAME_TIMECODE; st -> codec -> time_base . den = avio_r8 ( pb ); st -> codec -> time_base . num = 1; a . size = size - ( avio_tell ( pb ) - start_pos ); if ( a . size > 8 )  int ret ; if ( ( ret = mov_read_default ( c , pb , a ) ) < 0 )  static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom) if ( atom . size < 0 )  atom . size = INT64_MAX; while ( total_size + 8 <= atom . size && ! url_feof ( pb ) )  a . size = atom . size; a . type = 0; if ( atom . size >= 8 )  a . size = avio_rb32 ( pb ); a . type = avio_rl32 ( pb ); if ( atom . type != MKTAG ( 'r' , 'o' , 'o' , 't' ) && atom . type != MKTAG ( 'm' , 'o' , 'o' , 'v' ) )  if ( a . type == MKTAG ( 't' , 'r' , 'a' , 'k' ) || a . type == MKTAG ( 'm' , 'd' , 'a' , 't' ) )  av_log ( c -> fc , AV_LOG_ERROR , "Broken file, trak/mdat not at top-level\n" ); avio_skip ( pb , - 8 ); total_size += 8; if ( a . size == 1 )  a . size = avio_rb64 ( pb ) - 8; total_size += 8; av_dlog ( c -> fc , "type: %08x '%.4s' parent:'%.4s' sz: %" PRId64 " %" PRId64 " %" PRId64 "\n" a . type , ( char * ) & a . type , ( char * ) & atom . type , a . size , total_size , atom . size ) if ( a . size == 0 )  a . size = atom . size - total_size + 8; a . size -= 8; if ( a . size < 0 )  a . size = FFMIN ( a . size , atom . size - total_size ); if ( mov_default_parse_table [ i ] . type == a . type )  if ( ! parse && ( atom . type == MKTAG ( 'u' , 'd' , 't' , 'a' ) || atom . type == MKTAG ( 'i' , 'l' , 's' , 't' ) ) )  avio_skip ( pb , a . size ); int64_t start_pos = avio_tell ( pb ) ; int err = parse ( c , pb , a ) ; if ( err < 0 )  return err ; if ( c -> found_moov && c -> found_mdat && ( ( ! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX ) || start_pos + a . size == avio_size ( pb ) ) )  if ( ! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX )  c -> next_root_atom = start_pos + a . size; left = a . size - avio_tell ( pb ) + start_pos; if ( left > 0 )  avio_skip ( pb , left ); total_size += a . size; if ( total_size < atom . size && atom . size < 0x7ffff )  avio_skip ( pb , atom . size - total_size ); 