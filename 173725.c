static int CVE_2013_7008_PATCHED_decode_slice_header(H264Context *h, H264Context *h0) unsigned int first_mb_in_slice ; unsigned int pps_id ; int num_ref_idx_active_override_flag , ret ; unsigned int slice_type , tmp , i , j ; int last_pic_structure , last_pic_droppable ; int must_reinit ; int needs_reinit = 0 ; h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab; h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab; first_mb_in_slice = get_ue_golomb_long ( & h -> gb ); if ( first_mb_in_slice == 0 )  h0 -> current_slice = 0; if ( ! h0 -> first_field )  h -> cur_pic_ptr = NULL; slice_type = get_ue_golomb_31 ( & h -> gb ); if ( slice_type > 9 )  if ( slice_type > 4 )  slice_type -= 5; h -> slice_type_fixed = 0; slice_type = golomb_to_pict_type [ slice_type ]; h -> slice_type = slice_type; h -> slice_type_nos = slice_type & 3; h -> pict_type = h -> slice_type; pps_id = get_ue_golomb ( & h -> gb ); if ( pps_id >= MAX_PPS_COUNT )  if ( ! h0 -> pps_buffers [ pps_id ] )  h -> pps = * h0 -> pps_buffers [ pps_id ]; if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] )  if ( h -> pps . sps_id != h -> current_sps_id h0 -> sps_buffers [ h -> pps . sps_id ] -> new h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 h -> current_sps_id = h -> pps . sps_id; h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ]; if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc )  needs_reinit = 1; if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc )  h -> bit_depth_luma = h -> sps . bit_depth_luma; h -> chroma_format_idc = h -> sps . chroma_format_idc; needs_reinit = 1; if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 )  h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ); h -> avctx -> level = h -> sps . level_idc; h -> avctx -> refs = h -> sps . ref_frame_count; must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ); if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) )  must_reinit = 1; h -> mb_width = h -> sps . mb_width; h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ); h -> mb_num = h -> mb_width * h -> mb_height; h -> mb_stride = h -> mb_width + 1; h -> b_stride = h -> mb_width * 4; h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1; h -> width = 16 * h -> mb_width; h -> height = 16 * h -> mb_height; ret = init_dimensions ( h ); if ( ret < 0 )  if ( h -> sps . video_signal_type_present_flag )  h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG; if ( h -> sps . colour_description_present_flag )  if ( h -> avctx -> colorspace != h -> sps . colorspace )  needs_reinit = 1; h -> avctx -> color_primaries = h -> sps . color_primaries; h -> avctx -> color_trc = h -> sps . color_trc; h -> avctx -> colorspace = h -> sps . colorspace; if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) )  if ( h != h0 )  if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  h -> avctx -> pix_fmt = ret; if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 )  if ( ! h -> context_initialized )  if ( h != h0 )  if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 )  h -> avctx -> pix_fmt = ret; if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 )  if ( h == h0 && h -> dequant_coeff_pps != pps_id )  h -> dequant_coeff_pps = pps_id; h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ); h -> mb_mbaff = 0; h -> mb_aff_frame = 0; last_pic_structure = h0 -> picture_structure; last_pic_droppable = h0 -> droppable; h -> droppable = h -> nal_ref_idc == 0; if ( h -> sps . frame_mbs_only_flag )  h -> picture_structure = PICT_FRAME; if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B )  if ( get_bits1 ( & h -> gb ) )  h -> picture_structure = PICT_TOP_FIELD + get_bits1 ( & h -> gb ); h -> picture_structure = PICT_FRAME; h -> mb_aff_frame = h -> sps . mb_aff; h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME; if ( h0 -> current_slice != 0 )  if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable )  if ( ! h0 -> cur_pic_ptr )  if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 )  int unwrap_prev_frame_num = h -> prev_frame_num ; int max_frame_num = 1 << h -> sps . log2_max_frame_num ; if ( unwrap_prev_frame_num > h -> frame_num )  unwrap_prev_frame_num -= max_frame_num; if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count )  unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1; if ( unwrap_prev_frame_num < 0 )  unwrap_prev_frame_num += max_frame_num; h -> prev_frame_num = unwrap_prev_frame_num; if ( h0 -> first_field )  if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) )  if ( last_pic_droppable != h -> droppable )  h -> picture_structure = last_pic_structure; h -> droppable = last_pic_droppable; while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) )  Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; if ( ! h -> sps . gaps_in_frame_num_allowed_flag )  for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++) h -> last_pocs [ i ] = INT_MIN; if ( h264_frame_start ( h ) < 0 )  h -> prev_frame_num ++; h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num; h -> cur_pic_ptr -> frame_num = h -> prev_frame_num; if ( ( ret = ff_generate_sliding_window_mmcos ( h , 1 ) ) < 0 && h -> avctx -> err_recognition & AV_EF_EXPLODE )  if ( ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) )  if ( h -> short_ref_count )  if ( prev )  h -> short_ref [ 0 ] -> poc = prev -> poc + 2; h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num; if ( h0 -> first_field )  if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure )  h0 -> cur_pic_ptr = NULL; h0 -> first_field = FIELD_PICTURE ( h ); if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num )  h0 -> first_field = 1; h0 -> cur_pic_ptr = NULL; h0 -> first_field = 0; h0 -> first_field = FIELD_PICTURE ( h ); if ( ! FIELD_PICTURE ( h ) || h0 -> first_field )  if ( h264_frame_start ( h ) < 0 )  if ( FIELD_PICTURE ( h ) )  for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++) memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ); h0 -> last_slice_type = - 1; if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 )  for (i = 0; i < h->slice_context_count; i++) if ( h -> thread_context [ i ] )  ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ); if ( ret < 0 )  h -> cur_pic_ptr -> frame_num = h -> frame_num; if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num )  h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width; h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ); if ( h -> picture_structure == PICT_BOTTOM_FIELD )  h -> resync_mb_y = h -> mb_y = h -> mb_y + 1; if ( h -> picture_structure == PICT_FRAME )  h -> curr_pic_num = h -> frame_num; h -> max_pic_num = 1 << h -> sps . log2_max_frame_num; h -> curr_pic_num = 2 * h -> frame_num + 1; h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ); if ( h -> sps . poc_type == 0 )  h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ); if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  h -> delta_poc_bottom = get_se_golomb ( & h -> gb ); if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag )  h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ); if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME )  h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ); if ( h -> pps . redundant_pic_cnt_present )  h -> redundant_pic_count = get_ue_golomb ( & h -> gb ); h -> ref_count [ 0 ] = h -> pps . ref_count [ 0 ]; h -> ref_count [ 1 ] = h -> pps . ref_count [ 1 ]; if ( h -> slice_type_nos != AV_PICTURE_TYPE_I )  unsigned max [ 2 ] ; max [ 0 ] = max [ 1 ] = h -> picture_structure == PICT_FRAME ? 15 : 31; if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  h -> direct_spatial_mv_pred = get_bits1 ( & h -> gb ); num_ref_idx_active_override_flag = get_bits1 ( & h -> gb ); if ( num_ref_idx_active_override_flag )  h -> ref_count [ 0 ] = get_ue_golomb ( & h -> gb ) + 1; if ( h -> slice_type_nos == AV_PICTURE_TYPE_B )  h -> ref_count [ 1 ] = get_ue_golomb ( & h -> gb ) + 1; h -> ref_count [ 1 ] = 1; if ( h -> ref_count [ 0 ] - 1 > max [ 0 ] || h -> ref_count [ 1 ] - 1 > max [ 1 ] )  if ( slice_type != AV_PICTURE_TYPE_I && ( h0 -> current_slice == 0 || slice_type != h0 -> last_slice_type || memcmp ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> ref_count ) ) ) )  