Portal CreateNewPortal() static unsigned int unnamed_portal_count = 0 ; char portalname [ 64 ] ; unnamed_portal_count ++; sprintf ( portalname , "<unnamed portal %u>" , unnamed_portal_count ); if ( GetPortalByName ( portalname ) == ( ( void * ) 0 ) )  Portal GetPortalByName(const char *name) if ( ( ( const void * ) name ) != ( ( void * ) 0 ) )  hentry = ( ( PortalHashEnt * ) ( hash_search ( PortalHashTable , name , HASH_FIND , ( ( void * ) 0 ) ) ) ); if ( hentry )  portal = hentry -> portal; return portal ; return CreatePortal ( portalname , ( ( bool ) 0 ) , ( ( bool ) 0 ) ) ; Portal CreatePortal(const char *name,bool allowDup,bool dupSilent) portal = GetPortalByName ( name ); Portal GetPortalByName(const char *name) if ( ( ( const void * ) name ) != ( ( void * ) 0 ) )  hentry = ( ( PortalHashEnt * ) ( hash_search ( PortalHashTable , name , HASH_FIND , ( ( void * ) 0 ) ) ) ); if ( hentry )  portal = hentry -> portal; return portal ; if ( ( ( const void * ) portal ) != ( ( void * ) 0 ) )  if ( ! allowDup )  errstart ( 20 , "portalmem.c" , 208 , __func__ , ( ( void * ) 0 ) ) ? errfinish ( errcode ( ( '4' - 48 & 0x3F ) + ( ( '2' - 48 & 0x3F ) << 6 ) + ( ( 'P' - 48 & 0x3F ) << 12 ) + ( ( 48 - 48 & 0x3F ) << 18 ) + ( ( '3' - 48 & 0x3F ) << 24 ) ) , errmsg ( "cursor \"%s\" already exists" , name ) ) : ( ( void ) 0 ); if ( ! dupSilent )  errstart ( 19 , "portalmem.c" , 213 , __func__ , ( ( void * ) 0 ) ) ? errfinish ( errcode ( ( '4' - 48 & 0x3F ) + ( ( '2' - 48 & 0x3F ) << 6 ) + ( ( 'P' - 48 & 0x3F ) << 12 ) + ( ( 48 - 48 & 0x3F ) << 18 ) + ( ( '3' - 48 & 0x3F ) << 24 ) ) , errmsg ( "closing existing cursor \"%s\"" , name ) ) : ( ( void ) 0 ); PortalDrop ( portal , ( ( bool ) 0 ) ); void PortalDrop(Portal portal,bool isTopCommit) if ( portal -> portalPinned || ( portal -> status ) == PORTAL_ACTIVE )  errstart ( 20 , "portalmem.c" , 479 , __func__ , ( ( void * ) 0 ) ) ? errfinish ( errcode ( ( '2' - 48 & 0x3F ) + ( ( '4' - 48 & 0x3F ) << 6 ) + ( ( 48 - 48 & 0x3F ) << 12 ) + ( ( 48 - 48 & 0x3F ) << 18 ) + ( ( 48 - 48 & 0x3F ) << 24 ) ) , errmsg ( "cannot drop active portal \"%s\"" , portal -> name ) ) : ( ( void ) 0 ); if ( ( ( const void * ) ( portal -> cleanup ) ) != ( ( void * ) 0 ) )  ( * portal -> cleanup ) ( portal ); portal -> cleanup = ( ( void * ) 0 ); hentry = ( ( PortalHashEnt * ) ( hash_search ( PortalHashTable , ( portal -> name ) , HASH_REMOVE , ( ( void * ) 0 ) ) ) ); if ( hentry == ( ( void * ) 0 ) )  PortalReleaseCachedPlan ( portal ); static void PortalReleaseCachedPlan(Portal portal) if ( portal -> cplan )  ReleaseCachedPlan ( portal -> cplan , ( ( bool ) 0 ) ); portal -> cplan = ( ( void * ) 0 ); portal -> stmts = ( ( List * ) ( ( void * ) 0 ) ); if ( portal -> resowner && ( ! isTopCommit || ( portal -> status ) == PORTAL_FAILED ) )  bool isCommit = ( ( portal -> status ) != PORTAL_FAILED ) ; ResourceOwnerRelease ( portal -> resowner , RESOURCE_RELEASE_BEFORE_LOCKS , isCommit , ( ( bool ) 0 ) ); ResourceOwnerRelease ( portal -> resowner , RESOURCE_RELEASE_LOCKS , isCommit , ( ( bool ) 0 ) ); ResourceOwnerRelease ( portal -> resowner , RESOURCE_RELEASE_AFTER_LOCKS , isCommit , ( ( bool ) 0 ) ); ResourceOwnerDelete ( portal -> resowner ); portal -> resowner = ( ( void * ) 0 ); if ( portal -> holdStore )  oldcontext = MemoryContextSwitchTo ( portal -> holdContext ); tuplestore_end ( portal -> holdStore ); MemoryContextSwitchTo ( oldcontext ); portal -> holdStore = ( ( void * ) 0 ); if ( portal -> holdContext )  MemoryContextDelete ( portal -> holdContext ); MemoryContextDelete ( portal -> heap ); pfree ( portal ); portal = ( ( Portal ) ( MemoryContextAllocZero ( PortalMemory , sizeof ( ( * portal ) ) ) ) ); portal -> heap = AllocSetContextCreate ( PortalMemory , "PortalHeapMemory" , 0 , ( 1 * 1024 ) , ( 8 * 1024 ) ); portal -> resowner = ResourceOwnerCreate ( CurTransactionResourceOwner , "Portal" ); portal -> status = PORTAL_NEW; portal -> cleanup = PortalCleanup; portal -> createSubid = GetCurrentSubTransactionId ( ); portal -> strategy = PORTAL_MULTI_QUERY; portal -> cursorOptions = 0x0004; portal -> atStart = ( ( bool ) 1 ); portal -> atEnd = ( ( bool ) 1 ); portal -> visible = ( ( bool ) 1 ); portal -> creation_time = GetCurrentStatementStartTimestamp ( ); hentry = ( ( PortalHashEnt * ) ( hash_search ( PortalHashTable , name , HASH_ENTER , & found ) ) ); hentry -> portal = portal; portal -> name = ( hentry -> portalname ); return portal ; 