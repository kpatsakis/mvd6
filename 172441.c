 ArrayType::Setter(JSContext* cx, HandleObject obj, HandleId idval, bool strict, MutableHandleValue vp) if ( ! CData :: IsCData ( obj ) )   CData::IsCData(JSObject* obj) return JS_GetClass ( obj ) == & sCDataClass ; JSObject * typeObj = CData :: GetCType ( obj ) ;  CData::GetCType(JSObject* dataObj) jsval slot = JS_GetReservedSlot ( dataObj , SLOT_CTYPE ) ; JSObject * typeObj = slot . toObjectOrNull ( ) ; return typeObj ; if ( CType :: GetTypeCode ( typeObj ) != TYPE_array )   CType::GetTypeCode(JSObject* typeObj) jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ; return TypeCode ( result . toInt32 ( ) ) ; size_t index ; size_t length = GetLength ( typeObj ) ; bool ok = jsidToSize ( cx , idval , true , & index ) ; static jsidToSize(JSContext* cx, jsid val, bool allowString, size_t* result) if ( ! jsidToBigInteger ( cx , val , allowString , result ) )  template<class static jsidToBigInteger(JSContext* jsid bool IntegerType* result) if ( JSID_IS_INT ( val ) )  int32_t i = JSID_TO_INT ( val ) ; return ConvertExact ( i , result ) ; template<class TargetType, class static MOZ_ALWAYS_INLINE bool ConvertExact(FromType i, TargetType* result) return true ; if ( allowString && JSID_IS_STRING ( val ) )  return StringToInteger ( cx , JSID_TO_STRING ( val ) , result ) ; template <class IntegerType, class static StringToInteger(JSContext* cx, CharT* cp, size_t length, IntegerType* result) const CharT * end = cp + length ; if ( cp == end )  return false ; IntegerType sign = 1 ; if ( cp [ 0 ] == '-' )  return false ; sign = - 1; IntegerType base = 10 ; if ( end - cp > 2 && cp [ 0 ] == '0' && ( cp [ 1 ] == 'x' || cp [ 1 ] == 'X' ) )  cp += 2; base = 16; IntegerType i = 0 ; while ( cp != end )  char16_t c = * cp ++ ; if ( c >= '0' && c <= '9' )  c -= '0'; if ( base == 16 && c >= 'a' && c <= 'f' )  c = c - 'a' + 10; if ( base == 16 && c >= 'A' && c <= 'F' )  c = c - 'A' + 10; return false ; IntegerType ii = i ; i = ii * base + sign * c; if ( i / base != ii )  return false ; return true ; return false ; return false ; return Convert < size_t > ( double ( * result ) ) == * result ; int32_t dummy ; if ( ! ok && JSID_IS_STRING ( idval ) && ! StringToInteger ( cx , JSID_TO_STRING ( idval ) , & dummy ) )  template <class IntegerType, class static StringToInteger(JSContext* cx, CharT* cp, size_t length, IntegerType* result) const CharT * end = cp + length ; if ( cp == end )  return false ; IntegerType sign = 1 ; if ( cp [ 0 ] == '-' )  return false ; sign = - 1; IntegerType base = 10 ; if ( end - cp > 2 && cp [ 0 ] == '0' && ( cp [ 1 ] == 'x' || cp [ 1 ] == 'X' ) )  cp += 2; base = 16; IntegerType i = 0 ; while ( cp != end )  char16_t c = * cp ++ ; if ( c >= '0' && c <= '9' )  c -= '0'; if ( base == 16 && c >= 'a' && c <= 'f' )  c = c - 'a' + 10; if ( base == 16 && c >= 'A' && c <= 'F' )  c = c - 'A' + 10; return false ; IntegerType ii = i ; i = ii * base + sign * c; if ( i / base != ii )  return false ; return true ; if ( ! ok || index >= length )  JSObject * baseType = GetBaseType ( typeObj ) ; char * data = static_cast < char * > ( CData :: GetData ( obj ) ) + elementSize * index  CData::GetData(JSObject* dataObj) void * * buffer = static_cast < void * * > slot . toPrivate ( ) return * buffer ; return ImplicitConvert ( cx , vp , baseType , data , false , nullptr ) ; static ImplicitConvert(JSContext* HandleValue JSObject* void* bool bool* freePointer) RootedObject targetType ( cx , targetType_ ) ; JSObject * sourceData = nullptr ; JSObject * sourceType = nullptr ; RootedObject valObj ( cx , nullptr ) ; if ( val . isObject ( ) )  valObj = & val . toObject ( ); if ( CData :: IsCData ( valObj ) )  sourceData = valObj; sourceType = CData :: GetCType ( sourceData ); if ( CType :: TypesEqual ( sourceType , targetType ) )  if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )  sourceData = valObj; sourceType = CDataFinalizer :: GetCType ( cx , sourceData ); CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ; if ( ! p )  if ( CType :: TypesEqual ( sourceType , targetType ) )  TypeCode targetCode = CType :: GetTypeCode ( targetType ) ; switch ( targetCode )  bool result ; if ( ! jsvalToBool ( cx , val , & result ) )  * static_cast < bool * > ( buffer ) = result type result ; type result ; type result ; if ( ! jsvalToFloat ( cx , val , & result ) )  * static_cast < type * > ( buffer ) = result if ( val . isNull ( ) )  * static_cast < void * * > ( buffer ) = nullptr JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ; if ( sourceData )  TypeCode sourceCode = CType :: GetTypeCode ( sourceType ) ; bool voidptrTarget = CType :: GetTypeCode ( baseType ) == TYPE_void_t ; if ( sourceCode == TYPE_pointer && voidptrTarget )  if ( sourceCode == TYPE_array )  JSObject * elementType = ArrayType :: GetBaseType ( sourceType ) ; if ( voidptrTarget || CType :: TypesEqual ( baseType , elementType ) )  * static_cast < void * * > ( buffer ) = sourceBuffer if ( isArgument && val . isString ( ) )  if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )  if ( val . isObject ( ) && JS_IsArrayBufferViewObject ( valObj ) )  if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )  if ( ! isArgument )  void * ptr ; JS :: AutoCheckCannotGC nogc ; ptr = JS_GetArrayBufferViewData ( valObj , nogc ); if ( ! ptr )  * static_cast < void * * > ( buffer ) = ptr RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ; size_t targetLength = ArrayType :: GetLength ( targetType ) ; if ( val . isString ( ) )  JSString * sourceString = val . toString ( ) ; JSLinearString * sourceLinear = sourceString -> ensureLinear ( cx ) ; if ( ! sourceLinear )  switch ( CType :: GetTypeCode ( baseType ) )  size_t nbytes = GetDeflatedUTF8StringLength ( cx , sourceLinear ) ; if ( nbytes == ( size_t ) - 1 )  if ( targetLength < nbytes )  char * charBuffer = static_cast < char * > buffer if ( val . isObject ( ) && ! sourceData )  AutoIdArray props ( cx , JS_Enumerate ( cx , valObj ) ) ; if ( ! props )  size_t structSize = CType :: GetSize ( targetType ) ; auto intermediate = cx -> make_pod_array < char > ( structSize ) if ( ! intermediate )  const FieldInfoHash * fields = StructType :: GetFieldInfo ( targetType ) ; if ( props . length ( ) != fields -> count ( ) )  RootedId id ( cx ) ; for (size_t i = 0; i < props.length(); ++i) id = props [ i ]; if ( ! JSID_IS_STRING ( id ) )  JSFlatString * name = JSID_TO_FLAT_STRING ( id ) ; const FieldInfo * field = StructType :: LookupField ( cx , targetType , name ) ; if ( ! field )  RootedValue prop ( cx ) ; if ( ! JS_GetPropertyById ( cx , valObj , id , & prop ) )  char * fieldData = intermediate . get ( ) + field -> mOffset ; if ( ! ImplicitConvert ( cx , prop , field -> mType , fieldData , false , nullptr ) )  memcpy ( buffer , intermediate . get ( ) , structSize ); 