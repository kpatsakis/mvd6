void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag) dfaanalyze ( d , searchflag ); void dfaanalyze(struct dfa *d,int searchflag) size_t * nlastpos ; d -> searchflag = searchflag; nlastpos = ( ( sizeof ( ( * nlastpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nlastpos ) ) ) ) ); while ( 0 )  o_nlast = nlastpos; * ( nfirstpos ++ ) = * ( nlastpos ++ ) = 0; tmp . nelem = nfirstpos [ - 1 ]; tmp . elems = firstpos; pos = lastpos; for (j = 0; j < nlastpos[- 1]; ++j) merge ( ( & tmp ) , ( & d -> follows [ pos [ j ] . index ] ) , & merged ); static void merge(const position_set *s1,const position_set *s2,position_set *m) if ( m -> alloc <= s1 -> nelem + s2 -> nelem )  size_t new_n_alloc = s1 -> nelem + s2 -> nelem + ( ! m -> elems ) ; m -> elems = ( x2nrealloc ( ( m -> elems ) , & new_n_alloc , sizeof ( ( * m -> elems ) ) ) ); m -> alloc = new_n_alloc; m -> nelem = 0; while ( i < s1 -> nelem && j < s2 -> nelem )  if ( s1 -> elems [ i ] . index > s2 -> elems [ j ] . index )  m -> elems [ m -> nelem ++ ] = s1 -> elems [ i ++ ]; if ( s1 -> elems [ i ] . index < s2 -> elems [ j ] . index )  m -> elems [ m -> nelem ++ ] = s2 -> elems [ j ++ ]; m -> elems [ m -> nelem ] = s1 -> elems [ i ++ ]; m -> elems [ m -> nelem ++ ] . constraint |= s2 -> elems [ j ++ ] . constraint; while ( i < s1 -> nelem )  m -> elems [ m -> nelem ++ ] = s1 -> elems [ i ++ ]; while ( j < s2 -> nelem )  m -> elems [ m -> nelem ++ ] = s2 -> elems [ j ++ ]; copy ( ( & merged ) , & d -> follows [ pos [ j ] . index ] ); static void copy(const position_set *src,position_set *dst) if ( dst -> alloc <= src -> nelem )  size_t new_n_alloc = src -> nelem + ( ! dst -> elems ) ; dst -> elems = ( x2nrealloc ( ( dst -> elems ) , & new_n_alloc , sizeof ( ( * dst -> elems ) ) ) ); dst -> alloc = new_n_alloc; memcpy ( ( dst -> elems ) , ( src -> elems ) , sizeof ( dst -> elems [ 0 ] ) * src -> nelem ); dst -> nelem = src -> nelem; tmp . nelem = nfirstpos [ - 1 ]; tmp . elems = firstpos; pos = lastpos + nlastpos [ - 1 ]; for (j = 0; j < nlastpos[- 2]; ++j) merge ( ( & tmp ) , ( & d -> follows [ pos [ j ] . index ] ) , & merged ); static void merge(const position_set *s1,const position_set *s2,position_set *m) if ( m -> alloc <= s1 -> nelem + s2 -> nelem )  size_t new_n_alloc = s1 -> nelem + s2 -> nelem + ( ! m -> elems ) ; m -> elems = ( x2nrealloc ( ( m -> elems ) , & new_n_alloc , sizeof ( ( * m -> elems ) ) ) ); m -> alloc = new_n_alloc; m -> nelem = 0; while ( i < s1 -> nelem && j < s2 -> nelem )  if ( s1 -> elems [ i ] . index > s2 -> elems [ j ] . index )  m -> elems [ m -> nelem ++ ] = s1 -> elems [ i ++ ]; if ( s1 -> elems [ i ] . index < s2 -> elems [ j ] . index )  m -> elems [ m -> nelem ++ ] = s2 -> elems [ j ++ ]; m -> elems [ m -> nelem ] = s1 -> elems [ i ++ ]; m -> elems [ m -> nelem ++ ] . constraint |= s2 -> elems [ j ++ ] . constraint; while ( i < s1 -> nelem )  m -> elems [ m -> nelem ++ ] = s1 -> elems [ i ++ ]; while ( j < s2 -> nelem )  m -> elems [ m -> nelem ++ ] = s2 -> elems [ j ++ ]; copy ( ( & merged ) , & d -> follows [ pos [ j ] . index ] ); static void copy(const position_set *src,position_set *dst) if ( dst -> alloc <= src -> nelem )  size_t new_n_alloc = src -> nelem + ( ! dst -> elems ) ; dst -> elems = ( x2nrealloc ( ( dst -> elems ) , & new_n_alloc , sizeof ( ( * dst -> elems ) ) ) ); dst -> alloc = new_n_alloc; memcpy ( ( dst -> elems ) , ( src -> elems ) , sizeof ( dst -> elems [ 0 ] ) * src -> nelem ); dst -> nelem = src -> nelem; nfirstpos [ - 2 ] += nfirstpos [ - 1 ]; firstpos += nfirstpos [ - 1 ]; nlastpos [ - 2 ] += nlastpos [ - 1 ]; pos = lastpos + nlastpos [ - 2 ]; for (j = nlastpos[- 1]; j-- > 0; ) pos [ j ] = lastpos [ j ]; lastpos += nlastpos [ - 2 ]; nlastpos [ - 2 ] = nlastpos [ - 1 ]; nfirstpos [ - 2 ] += nfirstpos [ - 1 ]; nlastpos [ - 2 ] += nlastpos [ - 1 ]; * ( nfirstpos ++ ) = * ( nlastpos ++ ) = 1; firstpos -> index = lastpos -> index = i; firstpos -> constraint = lastpos -> constraint = 0x777; for (i = 0; i < nfirstpos[- 1]; ++i) insert ( firstpos [ i ] , & merged ); static void insert(position p,position_set *s) size_t count = s -> nelem ; size_t hi = count ; while ( lo < hi )  size_t mid = lo + hi >> 1 ; if ( s -> elems [ mid ] . index > p . index )  lo = mid + 1; hi = mid; if ( lo < count && p . index == s -> elems [ lo ] . index )  s -> elems [ lo ] . constraint |= p . constraint; if ( s -> alloc <= count + 1 )  size_t new_n_alloc = count + 1 + ( ! s -> elems ) ; s -> elems = ( x2nrealloc ( ( s -> elems ) , & new_n_alloc , sizeof ( ( * s -> elems ) ) ) ); s -> alloc = new_n_alloc; for (i = count; i > lo; i--) s -> elems [ i ] = s -> elems [ i - 1 ]; s -> elems [ lo ] = p; ++ s -> nelem; free ( o_nlast ); 