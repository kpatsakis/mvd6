static ppp_xmit_process(struct ppp *ppp) struct sk_buff * skb ; if ( ! ppp -> closing )  while ( ! ppp -> xmit_pending && ( skb = skb_dequeue ( & ppp -> file . xq ) ) )  ppp_send_frame ( ppp , skb ); static ppp_send_frame(struct ppp *ppp, struct sk_buff *skb) int proto = PPP_PROTO ( skb ) ; struct sk_buff * new_skb ; unsigned char * cp ; if ( proto < 0x8000 )  if ( ppp -> pass_filter && BPF_PROG_RUN ( ppp -> pass_filter , skb ) == 0 )  if ( ! ( ppp -> active_filter && BPF_PROG_RUN ( ppp -> active_filter , skb ) == 0 ) )  ppp -> last_xmit = jiffies; ppp -> stats64 . tx_bytes += skb -> len - 2; switch ( proto )  if ( ! ppp -> vj || ( ppp -> flags & SC_COMP_TCP ) == 0 )  new_skb = alloc_skb ( skb -> len + ppp -> dev -> hard_header_len - 2 , GFP_ATOMIC ); if ( ! new_skb )  cp = skb -> data + 2; if ( cp == skb -> data + 2 )  if ( cp [ 0 ] & SL_TYPE_COMPRESSED_TCP )  proto = PPP_VJC_COMP; proto = PPP_VJC_UNCOMP; skb = new_skb; if ( ( ppp -> xstate & SC_COMP_RUN ) && ppp -> xc_state && proto != PPP_LCP && proto != PPP_CCP )  if ( ! ( ppp -> flags & SC_CCP_UP ) && ( ppp -> flags & SC_MUST_COMP ) )  skb = pad_compress_skb ( ppp , skb ); static inline struct sk_buff pad_compress_skb(struct ppp *ppp, struct sk_buff *skb) struct sk_buff * new_skb ; int len ; int new_skb_size = ppp -> dev -> mtu + ppp -> xcomp -> comp_extra + ppp -> dev -> hard_header_len ; int compressor_skb_size = ppp -> dev -> mtu + ppp -> xcomp -> comp_extra + PPP_HDRLEN ; new_skb = alloc_skb ( new_skb_size , GFP_ATOMIC ); if ( ! new_skb )  return NULL ; len = ppp -> xcomp -> compress ( ppp -> xc_state , skb -> data - 2 , new_skb -> data , skb -> len + 2 , compressor_skb_size ); if ( len > 0 && ( ppp -> flags & SC_CCP_UP ) )  if ( len == 0 )  new_skb = skb; new_skb = NULL; return new_skb ; if ( ! skb )  if ( ppp -> flags & SC_LOOP_TRAFFIC )  ppp -> xmit_pending = skb; ppp_push ( ppp ); static ppp_push(struct ppp *ppp) struct list_head * list ; struct sk_buff * skb = ppp -> xmit_pending ; if ( ! skb )  list = & ppp -> channels; if ( list_empty ( list ) )  if ( ( ppp -> flags & SC_MULTILINK ) == 0 )  if ( ! ppp_mp_explode ( ppp , skb ) )  static int ppp_mp_explode(struct ppp *ppp, struct sk_buff *skb) int len , totlen ; int i , bits , hdrlen , mtu ; int flen ; int navail , nfree , nzero ; int nbigger ; int totspeed ; int totfree ; unsigned char * p , * q ; struct list_head * list ; struct channel * pch ; struct sk_buff * frag ; totspeed = 0; nfree = 0; navail = 0; nzero = 0; totfree = 0; hdrlen = ( ppp -> flags & SC_MP_XSHORTSEQ ) ? MPHDRLEN_SSN : MPHDRLEN; i = 0; if ( pch -> chan )  pch -> avail = 1; navail ++; pch -> speed = pch -> chan -> speed; pch -> avail = 0; if ( pch -> avail )  if ( skb_queue_empty ( & pch -> file . xq ) || ! pch -> had_frag )  if ( pch -> speed == 0 )  nzero ++; totspeed += pch -> speed; pch -> avail = 2; if ( ! pch -> had_frag && i < ppp -> nxchan )  ppp -> nxchan = i; if ( nfree == 0 || nfree < navail / 2 )  p = skb -> data; len = skb -> len; totlen = len; nbigger = len % nfree; list = & ppp -> channels; for (i = 0; i < ppp->nxchan; ++i) list = list -> next; if ( list == & ppp -> channels )  bits = B; while ( len > 0 )  list = list -> next; if ( list == & ppp -> channels )  pch = list_entry ( list , struct channel , clist ) if ( ! pch -> avail )  if ( pch -> avail == 1 )  if ( nfree > 0 )  pch -> avail = 1; if ( pch -> chan == NULL )  if ( pch -> speed == 0 )  nzero --; totspeed -= pch -> speed; pch -> avail = 0; totlen = len; totfree --; nfree --; if ( -- navail == 0 )  flen = len; if ( nfree > 0 )  if ( pch -> speed == 0 )  flen = len / nfree; if ( nbigger > 0 )  flen ++; nbigger --; flen = ( ( ( totfree - nzero ) * ( totlen + hdrlen * totfree ) ) / ( ( totspeed * totfree ) / pch -> speed ) ) - hdrlen; if ( nbigger > 0 )  flen += ( ( totfree - nzero ) * pch -> speed ) / totspeed; nbigger -= ( ( totfree - nzero ) * pch -> speed ) / totspeed; nfree --; if ( ( nfree <= 0 ) || ( flen > len ) )  flen = len; if ( flen <= 0 )  pch -> avail = 2; mtu = pch -> chan -> mtu - ( hdrlen - 2 ); if ( mtu < 4 )  mtu = 4; if ( flen > mtu )  flen = mtu; if ( flen == len )  bits |= E; frag = alloc_skb ( flen + hdrlen + ( flen == 0 ) , GFP_ATOMIC ); if ( ! frag )  q = skb_put ( frag , flen + hdrlen ); if ( ppp -> flags & SC_MP_XSHORTSEQ )  q [ 2 ] = bits; q [ 3 ] = ppp -> nxseq >> 16; q [ 4 ] = ppp -> nxseq >> 8; q [ 5 ] = ppp -> nxseq; memcpy ( q + hdrlen , p , flen ); pch -> had_frag = 1; p += flen; len -= flen; bits = 0; 