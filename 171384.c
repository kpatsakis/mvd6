 int avcodec_default_get_buffer(AVCodecContext *avctx, AVFrame *frame) return avcodec_default_get_buffer2 ( avctx , frame , 0 ) ; int avcodec_default_get_buffer2(AVCodecContext *avctx, AVFrame *frame, int flags) int ret ; if ( ( ret = update_frame_pool ( avctx , frame ) ) < 0 )  static int update_frame_pool(AVCodecContext *avctx, AVFrame *frame) FramePool * pool = avctx -> internal -> pool ; int i , ret ; switch ( avctx -> codec_type )  AVPicture picture ; int size [ 4 ] = { 0 } ; int h = frame -> height ; int tmpsize , unaligned ; if ( pool -> format == frame -> format && pool -> width == frame -> width && pool -> height == frame -> height )  return 0 ; unaligned = 0; for (i = 0; i < 4; i++) unaligned |= picture . linesize [ i ] % pool -> stride_align [ i ]; while ( unaligned )  tmpsize = av_image_fill_pointers ( picture . data , avctx -> pix_fmt , h , NULL , picture . linesize ); if ( tmpsize < 0 )  return - 1 ; for (i = 0; i < 3 && picture.data[i + 1]; i++) size [ i ] = picture . data [ i + 1 ] - picture . data [ i ]; size [ i ] = tmpsize - ( picture . data [ i ] - picture . data [ 0 ] ); for (i = 0; i < 4; i++) pool -> linesize [ i ] = picture . linesize [ i ]; if ( size [ i ] )  pool -> pools [ i ] = av_buffer_pool_init ( size [ i ] + 16 + STRIDE_ALIGN - 1 , CONFIG_MEMORY_POISONING ? NULL : av_buffer_allocz ); if ( ! pool -> pools [ i ] )  ret = AVERROR ( ENOMEM ); pool -> format = frame -> format; pool -> width = frame -> width; pool -> height = frame -> height; int ch = av_frame_get_channels ( frame ) ; int planar = av_sample_fmt_is_planar ( frame -> format ) ; int planes = planar ? ch : 1 ; if ( pool -> format == frame -> format && pool -> planes == planes && pool -> channels == ch && frame -> nb_samples == pool -> samples )  return 0 ; ret = av_samples_get_buffer_size ( & pool -> linesize [ 0 ] , ch , frame -> nb_samples , frame -> format , 0 ); if ( ret < 0 )  pool -> pools [ 0 ] = av_buffer_pool_init ( pool -> linesize [ 0 ] , NULL ); if ( ! pool -> pools [ 0 ] )  ret = AVERROR ( ENOMEM ); return 0 ; return ret ; frame -> type = FF_BUFFER_TYPE_INTERNAL; switch ( avctx -> codec_type )  return video_get_buffer ( avctx , frame ) ; static int video_get_buffer(AVCodecContext *s, AVFrame *pic) if ( pic -> data [ 0 ] )  memset ( pic -> data , 0 , sizeof ( pic -> data ) ); pic -> extended_data = pic -> data; for (i = 0; i < 4 && pool->pools[i]; i++) pic -> linesize [ i ] = pool -> linesize [ i ]; pic -> buf [ i ] = av_buffer_pool_get ( pool -> pools [ i ] ); if ( ! pic -> buf [ i ] )  pic -> data [ i ] = pic -> buf [ i ] -> data; for (; i < AV_NUM_DATA_POINTERS; i++) pic -> data [ i ] = NULL; pic -> linesize [ i ] = 0; if ( pic -> data [ 1 ] && ! pic -> data [ 2 ] )  avpriv_set_systematic_pal2 ( ( uint32_t * ) pic -> data [ 1 ] , s -> pix_fmt ); av_log ( s , AV_LOG_DEBUG , "default_get_buffer called on pic %p\n" , pic ); av_frame_unref ( pic ); 