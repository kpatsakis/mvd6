static int read_frame_internal(AVFormatContext *s,AVPacket *pkt) int got_packet = 0 ; while ( ! got_packet && ! s -> parse_queue )  AVStream * st ; AVPacket cur_pkt ; ret = ff_read_packet ( s , & cur_pkt ); if ( ret < 0 )  st = s -> streams [ cur_pkt . stream_index ]; if ( st -> need_parsing && ! st -> parser && ! ( s -> flags & 0x20 ) )  st -> parser = av_parser_init ( ( st -> codec -> codec_id ) ); if ( ! st -> parser )  st -> need_parsing = AVSTREAM_PARSE_NONE; if ( ( st -> need_parsing ) == AVSTREAM_PARSE_HEADERS )  st -> parser -> flags |= 0x1; if ( ( st -> need_parsing ) == AVSTREAM_PARSE_FULL_ONCE )  st -> parser -> flags |= 0x0002; if ( ( st -> need_parsing ) == AVSTREAM_PARSE_FULL_RAW )  st -> parser -> flags |= 0x1000; if ( ! st -> need_parsing || ! st -> parser )  * pkt = cur_pkt; got_packet = 1; if ( ( st -> discard ) < AVDISCARD_ALL )  if ( ( ret = parse_packet ( s , & cur_pkt , cur_pkt . stream_index ) ) < 0 )  static int parse_packet(AVFormatContext *s,AVPacket *pkt,int stream_index) AVPacket out_pkt = { ( 0 ) } ; AVStream * st = s -> streams [ stream_index ] ; uint8_t * data = pkt ? pkt -> data : ( ( void * ) 0 ) ; int size = pkt ? pkt -> size : 0 ; int ret = 0 ; int got_output = 0 ; if ( ! pkt )  pkt = & flush_pkt; got_output = 1; while ( size > 0 || pkt == & flush_pkt && got_output )  int len ; len = av_parser_parse2 ( st -> parser , st -> codec , & out_pkt . data , & out_pkt . size , data , size , pkt -> pts , pkt -> dts , pkt -> pos ); pkt -> pts = pkt -> dts = ( ( int64_t ) 0x8000000000000000UL ); pkt -> pos = ( - 1 ); data += len; size -= len; got_output = ! ( ! out_pkt . size ); if ( ! out_pkt . size )  out_pkt . duration = 0; if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_AUDIO )  if ( st -> codec -> sample_rate > 0 )  out_pkt . duration = ( av_rescale_q_rnd ( ( st -> parser -> duration ) , ( ( AVRational ) ( 1 ) , st -> codec -> sample_rate ) , st -> time_base , AV_ROUND_DOWN ) ) if ( st -> codec -> time_base . num != 0 && st -> codec -> time_base . den != 0 )  out_pkt . duration = ( av_rescale_q_rnd ( ( st -> parser -> duration ) , st -> codec -> time_base , st -> time_base , AV_ROUND_DOWN ) ); out_pkt . stream_index = st -> index; out_pkt . pts = st -> parser -> pts; out_pkt . dts = st -> parser -> dts; out_pkt . pos = st -> parser -> pos; if ( ( st -> need_parsing ) == AVSTREAM_PARSE_FULL_RAW )  out_pkt . pos = st -> parser -> frame_offset; if ( st -> parser -> key_frame == 1 || st -> parser -> key_frame == - 1 && st -> parser -> pict_type == AV_PICTURE_TYPE_I )  out_pkt . flags |= 0x1; if ( st -> parser -> key_frame == - 1 && st -> parser -> pict_type == AV_PICTURE_TYPE_NONE && pkt -> flags & 0x1 )  out_pkt . flags |= 0x1; if ( out_pkt . data == pkt -> data && out_pkt . size == pkt -> size )  out_pkt . destruct = pkt -> destruct; pkt -> destruct = ( ( void * ) 0 ); if ( ( ret = av_dup_packet ( & out_pkt ) ) < 0 )  if ( ! add_to_pktbuf ( & s -> parse_queue , & out_pkt , & s -> parse_queue_end ) )  static AVPacket *add_to_pktbuf(AVPacketList **packet_buffer,AVPacket *pkt,AVPacketList **plast_pktl) AVPacketList * pktl = ( av_mallocz ( sizeof ( AVPacketList ) ) ) ; if ( ! pktl )  return ( ( void * ) 0 ) ; pktl -> pkt = * pkt; return & pktl -> pkt ; ret = - 12; return ret ; if ( pkt -> flags & 0x1 )  st -> skip_to_keyframe = 0; if ( st -> skip_to_keyframe )  if ( got_packet )  * pkt = cur_pkt; got_packet = 0; int ff_read_packet(AVFormatContext *s,AVPacket *pkt) int ret ; int i ; AVStream * st ; AVPacketList * pktl = s -> raw_packet_buffer ; if ( pktl )  * pkt = pktl -> pkt; st = s -> streams [ pkt -> stream_index ]; if ( st -> request_probe <= 0 )  pkt -> data = ( ( void * ) 0 ); pkt -> size = 0; ret = ( ( s -> iformat -> read_packet ) ( s , pkt ) ); if ( ret < 0 )  if ( ! pktl || ret == - '\v' )  for (i = 0; i < s -> nb_streams; i++) st = s -> streams [ i ]; if ( st -> probe_packets )  probe_codec ( s , st , ( ( void * ) 0 ) ); if ( s -> flags & 0x0100 && pkt -> flags & 0x0002 )  if ( ( pkt -> stream_index ) >= ( ( unsigned int ) ( s -> nb_streams ) ) )  st = s -> streams [ pkt -> stream_index ]; pkt -> dts = wrap_timestamp ( st , pkt -> dts ); static int64_t wrap_timestamp(AVStream *st,int64_t timestamp) return timestamp ; pkt -> pts = wrap_timestamp ( st , pkt -> pts ); static int64_t wrap_timestamp(AVStream *st,int64_t timestamp) return timestamp ; if ( s -> use_wallclock_as_timestamps )  pkt -> dts = pkt -> pts = av_rescale_q ( av_gettime ( ) , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) , st -> time_base ) if ( ! pktl && st -> request_probe <= 0 )  s -> raw_packet_buffer_remaining_size -= pkt -> size; static void probe_codec(AVFormatContext *s,AVStream *st,const AVPacket *pkt) if ( st -> request_probe > 0 )  AVProbeData * pd = & st -> probe_data ; int end ; if ( pkt )  uint8_t * new_buf = ( av_realloc ( ( pd -> buf ) , ( pd -> buf_size + pkt -> size + 32 ) ) ) ; if ( ! new_buf )  pd -> buf = new_buf; memcpy ( ( pd -> buf + pd -> buf_size ) , ( pkt -> data ) , ( pkt -> size ) ); pd -> buf_size += pkt -> size; memset ( ( pd -> buf + pd -> buf_size ) , 0 , 32 ); st -> probe_packets = 0; end = s -> raw_packet_buffer_remaining_size <= 0 || st -> probe_packets <= 0; if ( end || ff_log2_c ( ( pd -> buf_size ) ) != ff_log2_c ( ( pd -> buf_size - pkt -> size ) ) )  int score = set_codec_from_probe_data ( s , st , pd ) ; static int set_codec_from_probe_data(AVFormatContext *s,AVStream *st,AVProbeData *pd) static const struct { const char * name ; enum AVCodecID id ; enum AVMediaType type ; } fmt_id_type [ ] = { { ( "aac" ) , ( AV_CODEC_ID_AAC ) , ( AVMEDIA_TYPE_AUDIO ) } , { ( "ac3" ) , ( AV_CODEC_ID_AC3 ) , ( AVMEDIA_TYPE_AUDIO ) } , { ( "dts" ) , ( AV_CODEC_ID_DTS ) , ( AVMEDIA_TYPE_AUDIO ) } , { ( "eac3" ) , ( AV_CODEC_ID_EAC3 ) , ( AVMEDIA_TYPE_AUDIO ) } , { ( "h264" ) , ( AV_CODEC_ID_H264 ) , ( AVMEDIA_TYPE_VIDEO ) } , { ( "loas" ) , ( AV_CODEC_ID_AAC_LATM ) , ( AVMEDIA_TYPE_AUDIO ) } , { ( "m4v" ) , ( AV_CODEC_ID_MPEG4 ) , ( AVMEDIA_TYPE_VIDEO ) } , { ( "mp3" ) , ( AV_CODEC_ID_MP3 ) , ( AVMEDIA_TYPE_AUDIO ) } , { ( "mpegvideo" ) , ( AV_CODEC_ID_MPEG2VIDEO ) , ( AVMEDIA_TYPE_VIDEO ) } , { ( 0 ) } } ; int score ; AVInputFormat * fmt = av_probe_input_format3 ( pd , 1 , & score ) ; AVInputFormat *av_probe_input_format3(AVProbeData *pd,int is_opened,int *score_ret) AVProbeData lpd = * pd ; AVInputFormat * fmt1 = ( ( void * ) 0 ) ; AVInputFormat * fmt ; int score ; int nodat = 0 ; int score_max = 0 ; static const uint8_t zerobuffer [ 32 ] ; if ( ! lpd . buf )  lpd . buf = zerobuffer; if ( lpd . buf_size > '\n' && ff_id3v2_match ( lpd . buf , "ID3" ) )  int id3len = ff_id3v2_tag_len ( lpd . buf ) ; if ( lpd . buf_size > id3len + 16 )  lpd . buf += id3len; lpd . buf_size -= id3len; nodat = 1; fmt = ( ( void * ) 0 ); while ( fmt1 = av_iformat_next ( fmt1 ) )  AVInputFormat *av_iformat_next(AVInputFormat *f) if ( f )  return f -> next ; return first_iformat ; if ( ! is_opened == ! ( fmt1 -> flags & 0x1 ) )  score = 0; if ( fmt1 -> read_probe )  score = ( ( fmt1 -> read_probe ) ( & lpd ) ); if ( fmt1 -> extensions && av_match_ext ( lpd . filename , fmt1 -> extensions ) )  int av_match_ext(const char *filename,const char *extensions) const char * ext ; const char * p ; char ext1 [ 32 ] ; char * q ; if ( ! filename )  return 0 ; ext = ( strrchr ( filename , '.' ) ); if ( ext )  ext ++; p = extensions; q = ext1; while ( ( * p ) != '\0' && ( * p ) != ',' && ( q - ext1 ) < sizeof ( ext1 ) - 1 )  * ( q ++ ) = * ( p ++ ); if ( ! av_strcasecmp ( ext1 , ext ) )  return 1 ; if ( ( * p ) == '\0' )  p ++; return 0 ; score = ( score > ( ( nodat ? 100 / 4 - 1 : 1 ) ) ? score : ( ( nodat ? 100 / 4 - 1 : 1 ) ) ); if ( fmt1 -> extensions )  if ( av_match_ext ( lpd . filename , fmt1 -> extensions ) )  int av_match_ext(const char *filename,const char *extensions) const char * ext ; const char * p ; char ext1 [ 32 ] ; char * q ; if ( ! filename )  return 0 ; ext = ( strrchr ( filename , '.' ) ); if ( ext )  ext ++; p = extensions; q = ext1; while ( ( * p ) != '\0' && ( * p ) != ',' && ( q - ext1 ) < sizeof ( ext1 ) - 1 )  * ( q ++ ) = * ( p ++ ); if ( ! av_strcasecmp ( ext1 , ext ) )  return 1 ; if ( ( * p ) == '\0' )  p ++; return 0 ; score = '2'; if ( score > score_max )  score_max = score; fmt = fmt1; if ( score == score_max )  fmt = ( ( void * ) 0 ); return fmt ; if ( fmt && st -> request_probe <= score )  int i ; for (i = 0; fmt_id_type[i] . name; i++) if ( ! strcmp ( fmt -> name , fmt_id_type [ i ] . name ) )  