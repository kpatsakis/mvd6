HTAB *hash_create(const char *tabname,long nelem,HASHCTL *info,int flags) HTAB * hashp ; HASHHDR * hctl ; if ( flags & 0x040 )  CurrentDynaHashCxt = TopMemoryContext; if ( flags & 0x200 )  CurrentDynaHashCxt = info -> hcxt; CurrentDynaHashCxt = TopMemoryContext; CurrentDynaHashCxt = AllocSetContextCreate ( CurrentDynaHashCxt , tabname , 0 , ( 8 * 1024 ) , ( 8 * 1024 * 1024 ) ); hashp = ( ( HTAB * ) ( DynaHashAlloc ( sizeof ( HTAB ) + strlen ( tabname ) + 1 ) ) ); static void *DynaHashAlloc(Size size) return MemoryContextAlloc ( CurrentDynaHashCxt , size ) ; hashp -> tabname = ( ( char * ) ( hashp + 1 ) ); strcpy ( hashp -> tabname , tabname ); if ( flags & 0x010 )  hashp -> hash = info -> hash; hashp -> hash = string_hash; if ( flags & 0x400 )  hashp -> match = info -> match; if ( hashp -> hash == string_hash )  hashp -> match = ( ( HashCompareFunc ) string_compare ); hashp -> match = memcmp; if ( flags & 0x800 )  if ( hashp -> hash == string_hash )  hashp -> keycopy = memcpy; if ( flags & 0x100 )  hashp -> alloc = info -> alloc; hashp -> alloc = DynaHashAlloc; if ( flags & 0x040 )  hashp -> hctl = info -> hctl; hashp -> dir = ( ( HASHSEGMENT * ) ( ( ( char * ) ( info -> hctl ) ) + sizeof ( HASHHDR ) ) ); hashp -> hcxt = ( ( void * ) 0 ); hashp -> isshared = ( ( bool ) 1 ); if ( flags & 0x080 )  hashp -> hctl = ( ( void * ) 0 ); hashp -> dir = ( ( void * ) 0 ); hashp -> hcxt = CurrentDynaHashCxt; hashp -> isshared = ( ( bool ) 0 ); if ( ! hashp -> hctl )  hashp -> hctl = ( ( HASHHDR * ) ( ( hashp -> alloc ) ( sizeof ( HASHHDR ) ) ) ); hashp -> frozen = ( ( bool ) 0 ); hctl = hashp -> hctl; if ( flags & 0x001 )  hctl -> num_partitions = info -> num_partitions; if ( flags & 0x002 )  hctl -> ssize = info -> ssize; hctl -> sshift = my_log2 ( info -> ssize ); int my_log2(long num) int i ; long limit ; if ( num > 9223372036854775807L / 2 )  num = 9223372036854775807L / 2; for ((i = 0 , limit = 1); limit < num; (i++ , limit <<= 1)) return i ; if ( flags & 0x008 )  hctl -> ffactor = info -> ffactor; if ( flags & 0x004 )  hctl -> max_dsize = info -> max_dsize; hctl -> dsize = info -> dsize; if ( flags & 0x020 )  hctl -> keysize = info -> keysize; hctl -> entrysize = info -> entrysize; hashp -> keysize = hctl -> keysize; hashp -> ssize = hctl -> ssize; hashp -> sshift = hctl -> sshift; if ( ! init_htab ( hashp , nelem ) )  static bool init_htab(HTAB *hashp,long nelem) HASHHDR * hctl = hashp -> hctl ; HASHSEGMENT * segp ; int nbuckets ; int nsegs ; if ( hctl -> num_partitions != 0 )  * ( ( volatile slock_t * ) ( & hctl -> mutex ) ) = 0; nbuckets = next_pow2_int ( ( nelem - 1 ) / hctl -> ffactor + 1 ); static int next_pow2_int(long num) if ( num > ( 2147483647 / 2 ) )  num = ( 2147483647 / 2 ); return 1 << my_log2 ( num ) ; int my_log2(long num) int i ; long limit ; if ( num > 9223372036854775807L / 2 )  num = 9223372036854775807L / 2; return i ; while ( nbuckets < hctl -> num_partitions )  nbuckets <<= 1; hctl -> max_bucket = hctl -> low_mask = ( nbuckets - 1 ); hctl -> high_mask = ( ( nbuckets << 1 ) - 1 ); nsegs = ( ( nbuckets - 1 ) / hctl -> ssize + 1 ); nsegs = next_pow2_int ( nsegs ); static int next_pow2_int(long num) if ( num > ( 2147483647 / 2 ) )  num = ( 2147483647 / 2 ); return 1 << my_log2 ( num ) ; if ( nsegs > hctl -> dsize )  if ( ! hashp -> dir )  hctl -> dsize = nsegs; if ( ! hashp -> dir )  hashp -> dir = ( ( HASHSEGMENT * ) ( ( hashp -> alloc ) ( ( hctl -> dsize ) * sizeof ( HASHSEGMENT ) ) ) ); if ( ! hashp -> dir )  for (segp = hashp -> dir; hctl -> nsegs < nsegs; (hctl -> nsegs++ , segp++)) * segp = seg_alloc ( hashp ); if ( * segp == ( ( void * ) 0 ) )  static HASHSEGMENT seg_alloc(HTAB *hashp) HASHSEGMENT segp ; segp = ( ( HASHSEGMENT ) ( ( hashp -> alloc ) ( sizeof ( HASHBUCKET ) * ( hashp -> ssize ) ) ) ); if ( ! segp )  void * _vstart = ( void * ) segp ; int _val = 0 ; Size _len = sizeof ( HASHBUCKET ) * ( hashp -> ssize ) ; if ( ( ( ( intptr_t ) _vstart ) & sizeof ( long ) - 1 ) == 0 && ( _len & sizeof ( long ) - 1 ) == 0 && _val == 0 && _len <= 1024 && 1024 != 0 )  memset ( _vstart , _val , _len ); while ( 0 )  