status_t MPEG4Source::parseSampleAuxiliaryInformationOffsets(off64_t offset, off64_t size) if ( mCurrentSamples . IsEmpty ( ) )  uint8_t version ; if ( mDataSource -> readAt ( offset , & version , sizeof ( version ) ) != 1 )  offset ++; uint32_t flags ; if ( ! mDataSource -> getUInt24 ( offset , & flags ) )  offset += 3; if ( flags & 1 )  offset += 8; uint32_t entrycount ; if ( ! mDataSource -> getUInt32 ( offset , & entrycount ) )  if ( entrycount > mCurrentSampleInfoOffsetsAllocSize )  mCurrentSampleInfoOffsets = ( uint64_t * ) realloc ( mCurrentSampleInfoOffsets , entrycount * 8 ); mCurrentSampleInfoOffsets [ i ] = tmp; mCurrentSampleInfoOffsets [ i ] = tmp; off64_t drmoffset = mCurrentSampleInfoOffsets [ 0 ] ; drmoffset += mCurrentMoofOffset; for (size_t i = 0; i < mCurrentSampleInfoCount; i++) Sample * smpl = & mCurrentSamples [ i ] ; memset ( smpl -> iv , 0 , 16 ); if ( mDataSource -> readAt ( drmoffset , smpl -> iv , ivlength ) != ivlength )  drmoffset += ivlength; smplinfosize = mCurrentSampleInfoSizes [ i ]; if ( smplinfosize > ivlength )  if ( ! mDataSource -> getUInt16 ( drmoffset , & numsubsamples ) )  drmoffset += 2; if ( ! mDataSource -> getUInt16 ( drmoffset , & numclear ) )  drmoffset += 2; if ( ! mDataSource -> getUInt32 ( drmoffset , & numencrypted ) )  drmoffset += 4; smpl -> clearsizes . AppendElement ( numclear ); smpl -> encryptedsizes . AppendElement ( numencrypted ); smpl -> clearsizes . AppendElement ( 0 ); smpl -> encryptedsizes . AppendElement ( smpl -> size ); 