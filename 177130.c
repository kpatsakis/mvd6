static void e100_nic_realize(PCIDevice *pci_dev, Error **errp) EEPRO100State * s = DO_UPCAST ( EEPRO100State , dev , pci_dev ) ; E100PCIDeviceInfo * info = eepro100_get_class ( s ) ; static E100PCIDeviceInfo *eepro100_get_class(EEPRO100State *s) return eepro100_get_class_by_name ( object_get_typename ( OBJECT ( s ) ) ) ; static E100PCIDeviceInfo *eepro100_get_class_by_name(const char *typename) E100PCIDeviceInfo * info = NULL ; int i ; for (i = 0; i < ARRAY_SIZE(e100_devices); i++) if ( strcmp ( e100_devices [ i ] . name , typename ) == 0 )  info = & e100_devices [ i ]; return info ; s -> device = info -> device; s -> eeprom = eeprom93xx_new ( & pci_dev -> qdev , EEPROM_SIZE ); nic_reset ( s ); static void nic_reset(void *opaque) EEPRO100State * s = opaque ; memset ( & s -> mult [ 0 ] , 0 , sizeof ( s -> mult ) ); nic_selective_reset ( s ); static void nic_selective_reset(EEPRO100State * s) memset ( s -> mem , 0 , sizeof ( s -> mem ) ); e100_write_reg4 ( s , SCBCtrlMDI , BIT ( 21 ) ); static void e100_write_reg4(EEPRO100State *s, E100RegisterOffset uint32_t val) assert ( ! ( ( uintptr_t ) & s -> mem [ addr ] & 3 ) ); cpu_to_le32w ( ( uint32_t * ) & s -> mem [ addr ] , val ); assert ( sizeof ( s -> mdimem ) == sizeof ( eepro100_mdi_default ) ); memcpy ( & s -> mdimem [ 0 ] , & eepro100_mdi_default [ 0 ] , sizeof ( s -> mdimem ) ); 