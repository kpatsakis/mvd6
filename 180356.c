emem_strbuf_t *ep_strbuf_new(const gchar *init) emem_strbuf_t * strbuf ; strbuf = ep_strbuf_sized_new ( next_size ( 0 , ( init ? strlen ( init ) + 1 : 0 ) , 0 ) , 0 ); static gsize next_size(gsize cur_alloc_len,gsize wanted_alloc_len,gsize max_alloc_len) if ( max_alloc_len < 1 || max_alloc_len > 65536 )  max_alloc_len = 65536; if ( cur_alloc_len < 1 )  cur_alloc_len = ( 240 / 10 ); while ( cur_alloc_len < wanted_alloc_len )  cur_alloc_len *= 2; return cur_alloc_len < max_alloc_len ? cur_alloc_len : max_alloc_len ; emem_strbuf_t *ep_strbuf_sized_new(gsize alloc_len,gsize max_alloc_len) emem_strbuf_t * strbuf ; strbuf = ( ep_alloc ( sizeof ( emem_strbuf_t ) ) ); void *ep_alloc(size_t size) return emem_alloc ( size , & ep_packet_mem ) ; static void *emem_alloc(size_t size,emem_header_t *mem) void * buf = ( mem -> memory_alloc ) ( size , mem ) ; return buf ; if ( max_alloc_len == 0 || max_alloc_len > 65536 )  max_alloc_len = 65536; if ( alloc_len == 0 )  alloc_len = 1; if ( alloc_len > max_alloc_len )  alloc_len = max_alloc_len; strbuf -> str = ( ep_alloc ( alloc_len ) ); void *ep_alloc(size_t size) return emem_alloc ( size , & ep_packet_mem ) ; strbuf -> str [ 0 ] = '\0'; strbuf -> len = 0; strbuf -> alloc_len = alloc_len; strbuf -> max_alloc_len = max_alloc_len; return strbuf ; full_len = g_strlcpy ( strbuf -> str , init , strbuf -> alloc_len ); strbuf -> len = ( full_len < strbuf -> alloc_len - 1 ? full_len : strbuf -> alloc_len - 1 ); return strbuf ; 