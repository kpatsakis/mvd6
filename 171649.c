 WebGLContext::ReadPixels(GLint x, GLint y, GLsizei GLsizei height, GLenum GLenum type, const Nullable<ArrayBufferView> ErrorResult& rv) if ( IsContextLost ( ) )  if ( mCanvasElement -> IsWriteOnly ( ) && ! nsContentUtils :: IsCallerChrome ( ) )  if ( width < 0 || height < 0 )  if ( pixels . IsNull ( ) )  const WebGLRectangleObject * framebufferRect = CurValidFBRectObject ( ) ; GLsizei framebufferWidth = framebufferRect ? framebufferRect -> Width ( ) : 0 ; GLsizei framebufferHeight = framebufferRect ? framebufferRect -> Height ( ) : 0 ; switch ( format )  channels = 1; channels = 3; channels = 4; uint32_t bytesPerPixel = 0 ; int requiredDataType = 0 ; bool isReadTypeValid = false ; bool isReadTypeFloat = false ; switch ( type )  isReadTypeValid = true; bytesPerPixel = 1 * channels; requiredDataType = js :: Scalar :: Uint8; isReadTypeValid = true; bytesPerPixel = 2; requiredDataType = js :: Scalar :: Uint16; if ( IsExtensionEnabled ( WebGLExtensionID :: WEBGL_color_buffer_float ) || IsExtensionEnabled ( WebGLExtensionID :: EXT_color_buffer_half_float ) )  isReadTypeValid = true; isReadTypeFloat = true; bytesPerPixel = 4 * channels; requiredDataType = js :: Scalar :: Float32; if ( ! isReadTypeValid )  const ArrayBufferView & pixbuf = pixels . Value ( ) ; int dataType = JS_GetArrayBufferViewType ( pixbuf . Obj ( ) ) ; if ( dataType != requiredDataType )  CheckedUint32 checked_neededByteLength = GetImageSize ( height , width , bytesPerPixel , mPixelStorePackAlignment ) ; if ( ! checked_neededByteLength . isValid ( ) )  uint32_t dataByteLen = pixbuf . Length ( ) ; if ( checked_neededByteLength . value ( ) > dataByteLen )  void * data = pixbuf . Data ( ) ; if ( ! data )  bool isSourceTypeFloat = false ; if ( mBoundFramebuffer && mBoundFramebuffer -> ColorAttachmentCount ( ) && mBoundFramebuffer -> ColorAttachment ( 0 ) . IsDefined ( ) )  isSourceTypeFloat = mBoundFramebuffer -> ColorAttachment ( 0 ) . IsReadableFloat ( ); if ( isReadTypeFloat != isSourceTypeFloat )  if ( mBoundFramebuffer )  if ( ! mBoundFramebuffer -> CheckAndInitializeAttachments ( ) )  bool isFormatAndTypeValid = false ; if ( gl -> IsSupported ( gl :: GLFeature :: ES2_compatibility ) )  GLenum implType = 0 ; GLenum implFormat = 0 ; if ( type == implType && format == implFormat )  isFormatAndTypeValid = true; switch ( format )  switch ( type )  isFormatAndTypeValid = true; if ( ! isFormatAndTypeValid )  if ( width == 0 || height == 0 )  if ( CanvasUtils :: CheckSaneSubrectSize ( x , y , width , height , framebufferWidth , framebufferHeight ) )  memset ( data , 0 , checked_neededByteLength . value ( ) ); 