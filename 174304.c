static tvbuff_t CVE_2011_1138_VULN_dissect_6lowpan_hc1(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint dgram_size, proto_item *length_item) gint offset = 0 ; gint bit_offset ; guint8 hc1_encoding ; guint8 next_header ; struct ip6_hdr ipv6 ; offset += sizeof ( guint8 ); hc1_encoding = tvb_get_guint8 ( tvb , offset ); next_header = ( ( hc1_encoding & LOWPAN_HC1_NEXT ) >> 1 ); offset += sizeof ( guint8 ); if ( hc1_encoding & LOWPAN_HC1_MORE )  if ( next_header == LOWPAN_HC1_NEXT_UDP )  offset += sizeof ( guint8 ); bit_offset = offset << 3; ipv6 . ip6_hops = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_HOP_LIMIT_BITS ); if ( ! ( hc1_encoding & LOWPAN_HC1_SOURCE_PREFIX ) )  memcpy ( ipv6 . ip6_src . bytes , lowpan_llprefix , sizeof ( lowpan_llprefix ) ); ipv6 . ip6_src . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); for (i=0; i<8; i++, bit_offset += 8) ipv6 . ip6_dst . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); for (i=8; i<16; i++, bit_offset += 8) ipv6 . ip6_dst . bytes [ i ] = tvb_get_bits8 ( tvb , bit_offset , 8 ); proto_tree_add_ipv6 ( tree , hf_6lowpan_dest , tvb , offset >> 3 , BITS_TO_BYTE_LEN ( offset , ( bit_offset - offset ) ) , ( guint8 * ) & ipv6 . ip6_dst ); ipv6_class = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_TRAFFIC_CLASS_BITS ); proto_tree_add_uint ( tree , hf_6lowpan_traffic_class , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_TRAFFIC_CLASS_BITS ) , ipv6_class ); bit_offset += LOWPAN_IPV6_TRAFFIC_CLASS_BITS; ipv6 . ip6_flow = tvb_get_bits32 ( tvb , bit_offset , LOWPAN_IPV6_FLOW_LABEL_BITS , FALSE ); proto_tree_add_uint ( tree , hf_6lowpan_flow_label , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_FLOW_LABEL_BITS ) , ipv6 . ip6_flow ); bit_offset += LOWPAN_IPV6_FLOW_LABEL_BITS; ipv6 . ip6_flow = g_ntohl ( ipv6 . ip6_flow | ( ipv6_class << LOWPAN_IPV6_FLOW_LABEL_BITS ) ); ipv6 . ip6_vfc = ( ( 0x6 << 4 ) | ( ipv6_class >> 4 ) ); ipv6 . ip6_nxt = IP_PROTO_UDP; ipv6 . ip6_nxt = IP_PROTO_ICMPV6; ipv6 . ip6_nxt = IP_PROTO_TCP; ipv6 . ip6_nxt = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_IPV6_NEXT_HEADER_BITS ); proto_tree_add_uint_format ( tree , hf_6lowpan_next_header , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_IPV6_NEXT_HEADER_BITS ) , ipv6 . ip6_nxt , "Next header: %s (0x%02x)" , ipprotostr ( ipv6 . ip6_nxt ) , ipv6 . ip6_nxt ); bit_offset += LOWPAN_IPV6_NEXT_HEADER_BITS; offset = bit_offset; udp . src_port = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_UDP_PORT_COMPRESSED_BITS ) + LOWPAN_PORT_12BIT_OFFSET; bit_offset += LOWPAN_UDP_PORT_COMPRESSED_BITS; udp . src_port = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_PORT_BITS , FALSE ); bit_offset += LOWPAN_UDP_PORT_BITS; proto_tree_add_uint ( tree , hf_6lowpan_udp_src , tvb , offset >> 3 , BITS_TO_BYTE_LEN ( offset , ( bit_offset - offset ) ) , udp . src_port ); udp . src_port = g_ntohs ( udp . src_port ); offset = bit_offset; udp . dst_port = tvb_get_bits8 ( tvb , bit_offset , LOWPAN_UDP_PORT_COMPRESSED_BITS ) + LOWPAN_PORT_12BIT_OFFSET; bit_offset += LOWPAN_UDP_PORT_COMPRESSED_BITS; udp . dst_port = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_PORT_BITS , FALSE ); bit_offset += LOWPAN_UDP_PORT_BITS; proto_tree_add_uint ( tree , hf_6lowpan_udp_dst , tvb , offset >> 3 , BITS_TO_BYTE_LEN ( offset , ( bit_offset - offset ) ) , udp . dst_port ); udp . dst_port = g_ntohs ( udp . dst_port ); udp . length = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_LENGTH_BITS , FALSE ); proto_tree_add_uint ( tree , hf_6lowpan_udp_len , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_UDP_LENGTH_BITS ) , udp . length ); bit_offset += LOWPAN_UDP_LENGTH_BITS; udp . length = dgram_size - ( gint ) sizeof ( struct ip6_hdr ); udp . length = tvb_reported_length ( tvb ); udp . length -= BITS_TO_BYTE_LEN ( 0 , bit_offset + LOWPAN_UDP_CHECKSUM_BITS ); udp . length += sizeof ( struct udp_hdr ); udp . length = g_ntohs ( udp . length ); udp . checksum = tvb_get_bits16 ( tvb , bit_offset , LOWPAN_UDP_CHECKSUM_BITS , FALSE ); proto_tree_add_uint ( tree , hf_6lowpan_udp_checksum , tvb , bit_offset >> 3 , BITS_TO_BYTE_LEN ( bit_offset , LOWPAN_UDP_CHECKSUM_BITS ) , udp . checksum ); bit_offset += LOWPAN_UDP_CHECKSUM_BITS; udp . checksum = g_ntohs ( udp . checksum ); offset = BITS_TO_BYTE_LEN ( 0 , bit_offset ); length = tvb_length_remaining ( tvb , offset ); nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + sizeof ( struct udp_hdr ) + length ); nhdr_list -> next = NULL; nhdr_list -> proto = IP_PROTO_UDP; nhdr_list -> length = length + sizeof ( struct udp_hdr ); nhdr_list -> reported = g_ntohs ( udp . length ); memcpy ( LOWPAN_NHDR_DATA ( nhdr_list ) , & udp , sizeof ( struct udp_hdr ) ); tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) + sizeof ( struct udp_hdr ) , offset , length ); offset = BITS_TO_BYTE_LEN ( 0 , bit_offset ); nhdr_list = ( struct lowpan_nhdr * ) ep_alloc ( sizeof ( struct lowpan_nhdr ) + tvb_length_remaining ( tvb , offset ) ); nhdr_list -> next = NULL; nhdr_list -> proto = ipv6 . ip6_nxt; nhdr_list -> length = tvb_length_remaining ( tvb , offset ); nhdr_list -> reported = tvb_reported_length_remaining ( tvb , offset ); nhdr_list -> reported = dgram_size - sizeof ( struct ip6_hdr ); tvb_memcpy ( tvb , LOWPAN_NHDR_DATA ( nhdr_list ) , offset , nhdr_list -> length ); ipv6_tvb = lowpan_reassemble_ipv6 ( tvb , & ipv6 , nhdr_list ); add_new_data_source ( pinfo , ipv6_tvb , "Decompressed 6LoWPAN header" ); return ipv6_tvb ; 