fragment_data fragment_end_seq_next(const packet_info *pinfo, const guint32 id, GHashTable GHashTable *reassembled_table) fragment_key key ; fragment_data * fd_head ; if ( pinfo -> fd -> flags . visited )  key . src = pinfo -> src; key . dst = pinfo -> dst; key . id = id; fd_head = g_hash_table_lookup ( fragment_table , & key ); if ( fd_head )  if ( fd_head -> flags & FD_DATA_NOT_PRESENT )  fd_head -> datalen = fd_head -> offset; fd_head -> flags |= FD_DATALEN_SET; fragment_defragment_and_free ( fd_head , pinfo ); static fragment_defragment_and_free (fragment_data *fd_head, const packet_info *pinfo) fragment_data * last_fd = NULL ; guint32 dfpos = 0 , size = 0 ; for(fd_i=fd_head->next;fd_i;fd_i=fd_i->next) if ( ! last_fd || last_fd -> offset != fd_i -> offset )  size += fd_i -> len; last_fd = fd_i; fd_head -> data = g_malloc ( size ); fd_head -> len = size; last_fd = NULL; for (fd_i=fd_head->next; fd_i; fd_i=fd_i->next) if ( fd_i -> len )  if ( ! last_fd || last_fd -> offset != fd_i -> offset )  fd_i -> flags |= FD_OVERLAP; if ( last_fd -> len != fd_i -> len || memcmp ( last_fd -> data , fd_i -> data , last_fd -> len ) )  fd_i -> flags |= FD_OVERLAPCONFLICT; last_fd = fd_i; 