static int corsair_probe(struct hid_device *dev, const struct hid_device_id *id) int ret ; unsigned long quirks = id -> driver_data ; struct corsair_drvdata * drvdata ; struct usb_interface * usbif = to_usb_interface ( dev -> dev . parent ) ; drvdata = devm_kzalloc ( & dev -> dev , sizeof ( struct corsair_drvdata ) , GFP_KERNEL ); if ( drvdata == NULL )  ret = hid_parse ( dev ); if ( ret != 0 )  ret = hid_hw_start ( dev , HID_CONNECT_DEFAULT ); if ( ret != 0 )  if ( usbif -> cur_altsetting -> desc . bInterfaceNumber == 0 )  if ( quirks & CORSAIR_USE_K90_MACRO )  ret = k90_init_macro_functions ( dev ); static int k90_init_macro_functions(struct hid_device *dev) struct k90_drvdata * k90 ; size_t name_sz ; k90 = kzalloc ( sizeof ( struct k90_drvdata ) , GFP_KERNEL ); if ( ! k90 )  name_sz = strlen ( dev_name ( & dev -> dev ) ) + sizeof ( K90_RECORD_LED_SUFFIX ); name = kzalloc ( name_sz , GFP_KERNEL ); if ( ! name )  k90 -> record_led . cdev . name = name; k90 -> record_led . cdev . max_brightness = 1; k90 -> record_led . cdev . brightness_set = k90_brightness_set; k90 -> record_led . cdev . brightness_get = k90_record_led_get; INIT_WORK ( & k90 -> record_led . work , k90_record_led_work ); k90 -> record_led . brightness = 0; ret = led_classdev_register ( & dev -> dev , & k90 -> record_led . cdev ); if ( ret != 0 )  if ( ret != 0 )  k90 -> record_led . removed = true; led_classdev_unregister ( & k90 -> record_led . cdev ); cancel_work_sync ( & k90 -> record_led . work ); kfree ( k90 -> record_led . cdev . name ); kfree ( k90 ); return ret ; 