void *emem_tree_lookup_string(emem_tree_t *se_tree,const gchar *k,guint32 flags) guint32 len = ( guint ) ( strlen ( k ) ) ; guint32 divx = ( len + 3 ) / 4 + 1 ; aligned = ( g_malloc ( divx * sizeof ( guint32 ) ) ); for (i = 0; i < len; i++) ch = ( ( unsigned char ) k [ i ] ); if ( ( * __ctype_b_loc ( ) ) [ ( int ) ch ] & ( ( unsigned short ) _ISupper ) )  ch = ( tolower ( ch ) ); tmp <<= 8; tmp |= ch; aligned [ i / 4 ] = tmp; if ( i % 4 != 0 )  while ( i % 4 != 0 )  i ++; tmp <<= 8; aligned [ i / 4 - 1 ] = tmp; aligned [ divx - 1 ] = 0x1; key [ 0 ] . length = divx; key [ 0 ] . key = aligned; key [ 1 ] . length = 0; key [ 1 ] . key = ( ( void * ) 0 ); ret = emem_tree_lookup32_array ( se_tree , key ); void *emem_tree_lookup32_array(emem_tree_t *se_tree,emem_tree_key_t *key) if ( ! se_tree || ! key )  for (cur_key = key; cur_key -> length > 0; cur_key++) if ( cur_key -> length > 100 )  for (i = 0; i < cur_key -> length; i++) if ( ! lookup_tree )  lookup_tree = se_tree; lookup_tree = ( emem_tree_lookup32 ( lookup_tree , lookup_key32 ) ); void *emem_tree_lookup32(emem_tree_t *se_tree,guint32 key) node = se_tree -> tree; while ( node )  if ( key == node -> key32 )  return node -> data ; if ( key < node -> key32 )  node = node -> left; if ( key > node -> key32 )  node = node -> right; if ( ! lookup_tree )  lookup_key32 = cur_key -> key [ i ]; if ( ! lookup_tree )  return emem_tree_lookup32 ( lookup_tree , lookup_key32 ) ; void *emem_tree_lookup32(emem_tree_t *se_tree,guint32 key) node = se_tree -> tree; while ( node )  if ( key == node -> key32 )  return node -> data ; if ( key < node -> key32 )  node = node -> left; if ( key > node -> key32 )  node = node -> right; g_free ( aligned ); return ret ; 