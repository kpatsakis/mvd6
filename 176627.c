qcms_profile* qcms_profile_from_file(FILE *file) size_t length ; qcms_profile * profile ; void * data ; if ( ( data == NULL ) || ( length == 0 ) )  profile = qcms_profile_from_memory ( data , length ); qcms_profile* qcms_profile_from_memory(const void *mem, size_t size) uint32_t length ; struct mem_source source ; struct mem_source * src = & source ; struct tag_index index ; qcms_profile * profile ; source . buf = mem; source . size = size; source . valid = true; if ( size < 4 )  length = read_u32 ( src , 0 ); if ( length <= size )  source . size = length; if ( source . size <= 64 || source . size >= MAX_PROFILE_SIZE )  profile = qcms_profile_create ( ); if ( ! profile )  if ( ! src -> valid )  index = read_tag_table ( profile , src ); if ( find_tag ( index , TAG_CHAD ) )  profile -> chromaticAdaption = read_tag_s15Fixed16ArrayType ( src , index , TAG_CHAD ); profile -> chromaticAdaption . invalid = true; if ( profile -> color_space == RGB_SIGNATURE )  if ( find_tag ( index , TAG_B2A0 ) )  if ( read_u32 ( src , find_tag ( index , TAG_B2A0 ) -> offset ) == LUT8_TYPE || read_u32 ( src , find_tag ( index , TAG_B2A0 ) -> offset ) == LUT16_TYPE )  if ( read_u32 ( src , find_tag ( index , TAG_B2A0 ) -> offset ) == LUT_MBA_TYPE )  profile -> mBA = read_tag_lutmABType ( src , index , TAG_B2A0 ); if ( find_tag ( index , TAG_rXYZ ) || ! qcms_supports_iccv4 )  profile -> redColorant = read_tag_XYZType ( src , index , TAG_rXYZ ); profile -> greenColorant = read_tag_XYZType ( src , index , TAG_gXYZ ); profile -> blueColorant = read_tag_XYZType ( src , index , TAG_bXYZ ); if ( ! src -> valid )  if ( find_tag ( index , TAG_rTRC ) || ! qcms_supports_iccv4 )  profile -> redTRC = read_tag_curveType ( src , index , TAG_rTRC ); profile -> greenTRC = read_tag_curveType ( src , index , TAG_gTRC ); profile -> blueTRC = read_tag_curveType ( src , index , TAG_bTRC ); if ( ! profile -> redTRC || ! profile -> blueTRC || ! profile -> greenTRC )  if ( profile -> color_space == GRAY_SIGNATURE )  profile -> grayTRC = read_tag_curveType ( src , index , TAG_kTRC ); if ( ! profile -> grayTRC )  if ( ! src -> valid )  qcms_profile_release ( profile ); void qcms_profile_release(qcms_profile *profile) if ( profile -> mBA )  mAB_release ( profile -> mBA ); static void mAB_release(struct lutmABType *lut) uint8_t i ; for (i = 0; i < lut->num_in_channels; i++) free ( lut -> a_curves [ i ] ); 