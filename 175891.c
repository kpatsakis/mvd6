void *hash_search(HTAB *hashp,const void *keyPtr,HASHACTION action,bool *foundPtr) return hash_search_with_hash_value ( hashp , keyPtr , ( ( hashp -> hash ) ( keyPtr , hashp -> keysize ) ) , action , foundPtr ) ; void *hash_search_with_hash_value(HTAB *hashp,const void *keyPtr,uint32 hashvalue,HASHACTION action,bool *foundPtr) HASHHDR * hctl = hashp -> hctl ; if ( action == HASH_ENTER || action == HASH_ENTER_NULL )  if ( ! ( hctl -> num_partitions != 0 ) && ! hashp -> frozen && hctl -> nentries / ( ( long ) ( hctl -> max_bucket + 1 ) ) >= hctl -> ffactor && ! has_seq_scans ( hashp ) )  static bool has_seq_scans(HTAB *hashp) int i ; for (i = 0; i < num_seq_scans; i++) if ( seq_scan_tables [ i ] == hashp )  return ( bool ) 1 ; return ( bool ) 0 ; ( void ) ( expand_table ( hashp ) ); static bool expand_table(HTAB *hashp) HASHHDR * hctl = hashp -> hctl ; long new_bucket ; long new_segnum ; new_bucket = ( hctl -> max_bucket + 1 ); new_segnum = new_bucket >> hashp -> sshift; if ( new_segnum >= hctl -> nsegs )  if ( new_segnum >= hctl -> dsize )  if ( ! dir_realloc ( hashp ) )  static bool dir_realloc(HTAB *hashp) HASHSEGMENT * p ; long new_dsize ; long new_dirsize ; if ( hashp -> hctl -> max_dsize != ( - 1 ) )  return ( bool ) 0 ; new_dsize = hashp -> hctl -> dsize << 1; new_dirsize = ( new_dsize * sizeof ( HASHSEGMENT ) ); p = ( ( HASHSEGMENT * ) ( ( hashp -> alloc ) ( ( ( Size ) new_dirsize ) ) ) ); if ( p != ( ( void * ) 0 ) )  return ( bool ) 1 ; return ( bool ) 0 ; if ( ! ( hashp -> dir [ new_segnum ] = seg_alloc ( hashp ) ) )  static HASHSEGMENT seg_alloc(HTAB *hashp) HASHSEGMENT segp ; segp = ( ( HASHSEGMENT ) ( ( hashp -> alloc ) ( sizeof ( HASHBUCKET ) * ( hashp -> ssize ) ) ) ); if ( ! segp )  void * _vstart = ( void * ) segp ; int _val = 0 ; Size _len = sizeof ( HASHBUCKET ) * ( hashp -> ssize ) ; if ( ( ( ( intptr_t ) _vstart ) & sizeof ( long ) - 1 ) == 0 && ( _len & sizeof ( long ) - 1 ) == 0 && _val == 0 && _len <= 1024 && 1024 != 0 )  memset ( _vstart , _val , _len ); while ( 0 )  